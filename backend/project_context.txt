
[Project Structure]: C:\Users\SSAFY\Desktop\S14P11A202\backend
========================================
backend/
    .dockerignore
    alembic.ini
    Dockerfile
    environment.yaml
    README.md
    requirements.txt
    alembic/
        env.py
        README
        script.py.mako
        versions/
            2b87114328d5_add_cart_session_pairing_token.py
            3fd7de1c788e_add_camera_on_to_cart_session.py
            4977b62bd2e4_remove_cart_session_pairing_fields.py
            4e8c53bbb5bf_initial_migration.py
            5e709302d134_add_camera_view_on_to_cart_session.py
            82d52c882a35_make_zone_code_and_category_id_not_null.py
            e0e8a64d1b86_rename_camera_on_to_camera_view_on.py
    app/
        check_data.py
        database.py
        dependencies.py
        init_db.py
        main.py
        models.py
        schemas.py
        seed_data.py
        __init__.py
        core/
            config.py
        db/
            base.py
        routers/
            auth.py
            cart.py
            ledger.py
            payment.py
            product.py
            recommendation.py
            user.py
            __init__.py
        utils/
            check_data.py
            email.py
            jwt.py
            security.py
    scripts/
        reset_db.py
        run_sql.py
        seed_data.sql
    tests/
        manual/
            check_db_data.py
            test_payment_approve.py
            test_payment_flow.py
========================================

[File Contents]
========================================

Start of file: README.md
----------------------------------------
# Backend (Main API Server)

ì´ ë””ë ‰í† ë¦¬ëŠ” ì„œë¹„ìŠ¤ì˜ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” **Main API Server**ì…ë‹ˆë‹¤.



## 1. ë””ë ‰í† ë¦¬ êµ¬ì¡°

- **`app/`**: FastAPI ì†ŒìŠ¤ ì½”ë“œ ë©”ì¸ íŒ¨í‚¤ì§€
  - **`main.py`**: ì•± ì§„ì…ì  ë° FastAPI ì„¤ì •
  - **`routers/`**: API ì—”ë“œí¬ì¸íŠ¸ ëª¨ìŒ
  - **`models.py`**: SQLAlchemy DB ëª¨ë¸ ì •ì˜
  - **`schemas.py`**: Pydantic DTO ì •ì˜
  - **`database.py`**: DB ì—°ê²° ì„¸ì…˜ ê´€ë¦¬
- **`Dockerfile`**: ë°±ì—”ë“œ ì„œë²„ ì»¨í…Œì´ë„ˆ ë¹Œë“œ íŒŒì¼
- **`requirements.txt`**: ì˜ì¡´ì„± íŒ¨í‚¤ì§€ ëª©ë¡



## 2. ê°œë°œ í™˜ê²½

- **Language**: Python 3.12.9
- **Framework**: FastAPI 0.128.0
- **Database**: PostgreSQL 16.x (w/ pgvector)
- **Storage**: MinIO (S3 Compatible) 7.2.20



## 3. ì‹¤í–‰ ê°€ì´ë“œ


----------------------------------------
End of file: README.md


Start of file: requirements.txt
----------------------------------------
fastapi==0.128.0
uvicorn[standard]
sqlalchemy
psycopg2-binary
python-multipart
boto3
mlflow>=3.0.0
pgvector
httpx==0.28.1
python-dotenv==1.2.1
numpy==2.4.1
passlib[argon2]
python-jose[cryptography]
email-validator
pydantic-settings
alembic
psycopg2-binary

----------------------------------------
End of file: requirements.txt


Start of file: alembic\env.py
----------------------------------------
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
import sys
from pathlib import Path

sys.path.append(str(Path(__file__).resolve().parents[1]))

from app.database import Base
from app.models import *

import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is not set")


target_metadata = Base.metadata

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config
config.set_main_option("sqlalchemy.url", DATABASE_URL)

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

----------------------------------------
End of file: alembic\env.py


Start of file: alembic\versions\2b87114328d5_add_cart_session_pairing_token.py
----------------------------------------
"""add cart session pairing token

Revision ID: 2b87114328d5
Revises: 82d52c882a35
Create Date: 2026-01-30 14:39:02.455285

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '2b87114328d5'
down_revision: Union[str, Sequence[str], None] = '82d52c882a35'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('cart_session', sa.Column('pairing_token', sa.String(length=64), nullable=True))
    op.add_column('cart_session', sa.Column('paired_at', sa.DateTime(timezone=True), nullable=True))
    op.create_unique_constraint(None, 'cart_session', ['pairing_token'])
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'cart_session', type_='unique')
    op.drop_column('cart_session', 'paired_at')
    op.drop_column('cart_session', 'pairing_token')
    # ### end Alembic commands ###

----------------------------------------
End of file: alembic\versions\2b87114328d5_add_cart_session_pairing_token.py


Start of file: alembic\versions\3fd7de1c788e_add_camera_on_to_cart_session.py
----------------------------------------
"""add camera_on to cart_session

Revision ID: 3fd7de1c788e
Revises: 45a09416681f
Create Date: 2026-01-30 09:57:10.020006

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '3fd7de1c788e'
down_revision: Union[str, Sequence[str], None] = '45a09416681f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('cart_session', sa.Column('camera_on', sa.Boolean(), nullable=True))
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('cart_session', 'camera_on')
    # ### end Alembic commands ###

----------------------------------------
End of file: alembic\versions\3fd7de1c788e_add_camera_on_to_cart_session.py


Start of file: alembic\versions\4977b62bd2e4_remove_cart_session_pairing_fields.py
----------------------------------------
"""remove cart session pairing fields

Revision ID: 4977b62bd2e4
Revises: 2b87114328d5
Create Date: 2026-01-30 14:50:33.934586

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '4977b62bd2e4'
down_revision: Union[str, Sequence[str], None] = '2b87114328d5'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(op.f('cart_session_pairing_token_key'), 'cart_session', type_='unique')
    op.drop_column('cart_session', 'paired_at')
    op.drop_column('cart_session', 'pairing_token')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('cart_session', sa.Column('pairing_token', sa.VARCHAR(length=64), autoincrement=False, nullable=True))
    op.add_column('cart_session', sa.Column('paired_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True))
    op.create_unique_constraint(op.f('cart_session_pairing_token_key'), 'cart_session', ['pairing_token'], postgresql_nulls_not_distinct=False)
    # ### end Alembic commands ###

----------------------------------------
End of file: alembic\versions\4977b62bd2e4_remove_cart_session_pairing_fields.py


Start of file: alembic\versions\4e8c53bbb5bf_initial_migration.py
----------------------------------------
"""initial_migration

Revision ID: 4e8c53bbb5bf
Revises: 
Create Date: 2026-01-30 14:28:40.290367

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
import pgvector

# revision identifiers, used by Alembic.
revision: str = '4e8c53bbb5bf'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('app_user',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('provider', sa.Enum('LOCAL', 'GOOGLE', 'KAKAO', name='userprovider'), nullable=False),
    sa.Column('nickname', sa.String(length=40), nullable=False),
    sa.Column('password_hash', sa.String(length=255), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('user_id'),
    sa.UniqueConstraint('email')
    )
    op.create_index(op.f('ix_app_user_user_id'), 'app_user', ['user_id'], unique=False)
    op.create_table('cart_device',
    sa.Column('cart_device_id', sa.Integer(), nullable=False),
    sa.Column('device_code', sa.String(length=64), nullable=False),
    sa.PrimaryKeyConstraint('cart_device_id'),
    sa.UniqueConstraint('device_code')
    )
    op.create_index(op.f('ix_cart_device_cart_device_id'), 'cart_device', ['cart_device_id'], unique=False)
    op.create_table('product_category',
    sa.Column('category_id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=60), nullable=False),
    sa.Column('zone_code', sa.String(length=30), nullable=True),
    sa.PrimaryKeyConstraint('category_id'),
    sa.UniqueConstraint('name')
    )
    op.create_index(op.f('ix_product_category_category_id'), 'product_category', ['category_id'], unique=False)
    op.create_table('recipe',
    sa.Column('recipe_id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('instructions', sa.Text(), nullable=True),
    sa.Column('image_url', sa.Text(), nullable=True),
    sa.Column('embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('recipe_id')
    )
    op.create_index(op.f('ix_recipe_recipe_id'), 'recipe', ['recipe_id'], unique=False)
    op.create_table('cart_session',
    sa.Column('cart_session_id', sa.Integer(), nullable=False),
    sa.Column('cart_device_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('status', sa.Enum('ACTIVE', 'CHECKOUT_REQUESTED', 'PAID', 'CANCELLED', name='cartsessionstatus'), nullable=False),
    sa.Column('budget_limit', sa.Integer(), nullable=True),
    sa.Column('expected_total_g', sa.Integer(), nullable=True),
    sa.Column('measured_total_g', sa.Integer(), nullable=True),
    sa.Column('started_at', sa.DateTime(timezone=True), nullable=False),
    sa.Column('ended_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['cart_device_id'], ['cart_device.cart_device_id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ),
    sa.PrimaryKeyConstraint('cart_session_id')
    )
    op.create_index(op.f('ix_cart_session_cart_session_id'), 'cart_session', ['cart_session_id'], unique=False)
    op.create_table('password_reset_token',
    sa.Column('token', sa.String(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('expires_at', sa.TIMESTAMP(), nullable=False),
    sa.Column('used', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ),
    sa.PrimaryKeyConstraint('token')
    )
    op.create_table('payment_method',
    sa.Column('method_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('method_type', sa.Enum('CARD', 'KAKAO_PAY', name='paymentmethodtype'), nullable=False),
    sa.Column('billing_key', sa.String(length=255), nullable=True),
    sa.Column('card_brand', sa.String(length=30), nullable=True),
    sa.Column('card_last4', sa.String(length=4), nullable=True),
    sa.Column('is_default', sa.Boolean(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('method_id')
    )
    op.create_index(op.f('ix_payment_method_method_id'), 'payment_method', ['method_id'], unique=False)
    op.create_table('product',
    sa.Column('product_id', sa.Integer(), nullable=False),
    sa.Column('category_id', sa.Integer(), nullable=True),
    sa.Column('barcode', sa.String(length=64), nullable=True),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('price', sa.Integer(), nullable=False),
    sa.Column('unit_weight_g', sa.Integer(), nullable=False),
    sa.Column('stock_quantity', sa.Integer(), nullable=True),
    sa.Column('image_url', sa.Text(), nullable=True),
    sa.Column('product_info', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('embedding', pgvector.sqlalchemy.vector.VECTOR(dim=1536), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['category_id'], ['product_category.category_id'], ),
    sa.PrimaryKeyConstraint('product_id'),
    sa.UniqueConstraint('barcode')
    )
    op.create_index(op.f('ix_product_product_id'), 'product', ['product_id'], unique=False)
    op.create_table('saved_recipe',
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('recipe_id', sa.Integer(), nullable=False),
    sa.Column('saved_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['recipe_id'], ['recipe.recipe_id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('user_id', 'recipe_id')
    )
    op.create_table('cart_detection_log',
    sa.Column('log_id', sa.Integer(), nullable=False),
    sa.Column('cart_session_id', sa.Integer(), nullable=False),
    sa.Column('cart_device_id', sa.Integer(), nullable=False),
    sa.Column('product_id', sa.Integer(), nullable=True),
    sa.Column('action_type', sa.Enum('ADD', 'REMOVE', name='detectionactiontype'), nullable=False),
    sa.Column('confidence_score', sa.Numeric(precision=5, scale=2), nullable=True),
    sa.Column('detected_weight_g', sa.Integer(), nullable=True),
    sa.Column('is_applied', sa.Boolean(), nullable=True),
    sa.Column('detected_at', sa.DateTime(timezone=True), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['cart_device_id'], ['cart_device.cart_device_id'], ),
    sa.ForeignKeyConstraint(['cart_session_id'], ['cart_session.cart_session_id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['product_id'], ['product.product_id'], ),
    sa.PrimaryKeyConstraint('log_id')
    )
    op.create_index(op.f('ix_cart_detection_log_log_id'), 'cart_detection_log', ['log_id'], unique=False)
    op.create_table('cart_item',
    sa.Column('cart_item_id', sa.Integer(), nullable=False),
    sa.Column('cart_session_id', sa.Integer(), nullable=False),
    sa.Column('product_id', sa.Integer(), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('unit_price', sa.Integer(), nullable=False),
    sa.Column('added_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['cart_session_id'], ['cart_session.cart_session_id'], ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['product_id'], ['product.product_id'], ),
    sa.PrimaryKeyConstraint('cart_item_id')
    )
    op.create_index(op.f('ix_cart_item_cart_item_id'), 'cart_item', ['cart_item_id'], unique=False)
    op.create_table('payment',
    sa.Column('payment_id', sa.Integer(), nullable=False),
    sa.Column('cart_session_id', sa.Integer(), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('method_id', sa.Integer(), nullable=True),
    sa.Column('pg_provider', sa.Enum('KAKAO_PAY', 'CARD_PG', name='pgprovidertype'), nullable=False),
    sa.Column('pg_tid', sa.String(length=255), nullable=True),
    sa.Column('status', sa.Enum('PENDING', 'APPROVED', 'FAILED', 'CANCELLED', name='paymentstatus'), nullable=False),
    sa.Column('total_amount', sa.Integer(), nullable=False),
    sa.Column('approved_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['cart_session_id'], ['cart_session.cart_session_id'], ),
    sa.ForeignKeyConstraint(['method_id'], ['payment_method.method_id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ),
    sa.PrimaryKeyConstraint('payment_id'),
    sa.UniqueConstraint('cart_session_id')
    )
    op.create_index(op.f('ix_payment_payment_id'), 'payment', ['payment_id'], unique=False)
    op.create_table('recipe_ingredient',
    sa.Column('recipe_id', sa.Integer(), nullable=False),
    sa.Column('product_id', sa.Integer(), nullable=False),
    sa.Column('quantity_info', sa.String(length=50), nullable=True),
    sa.Column('importance_score', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['product.product_id'], ),
    sa.ForeignKeyConstraint(['recipe_id'], ['recipe.recipe_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('recipe_id', 'product_id')
    )
    op.create_table('ledger_entry',
    sa.Column('ledger_entry_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('payment_id', sa.Integer(), nullable=True),
    sa.Column('spend_date', sa.Date(), nullable=False),
    sa.Column('category', sa.Enum('GROCERY', 'MEAT', 'DAIRY', 'BEVERAGE', 'SNACK', 'HOUSEHOLD', 'ETC', name='ledgercategory'), nullable=False),
    sa.Column('amount', sa.Integer(), nullable=False),
    sa.Column('memo', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['payment_id'], ['payment.payment_id'], ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['user_id'], ['app_user.user_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('ledger_entry_id')
    )
    op.create_index(op.f('ix_ledger_entry_ledger_entry_id'), 'ledger_entry', ['ledger_entry_id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_ledger_entry_ledger_entry_id'), table_name='ledger_entry')
    op.drop_table('ledger_entry')
    op.drop_table('recipe_ingredient')
    op.drop_index(op.f('ix_payment_payment_id'), table_name='payment')
    op.drop_table('payment')
    op.drop_index(op.f('ix_cart_item_cart_item_id'), table_name='cart_item')
    op.drop_table('cart_item')
    op.drop_index(op.f('ix_cart_detection_log_log_id'), table_name='cart_detection_log')
    op.drop_table('cart_detection_log')
    op.drop_table('saved_recipe')
    op.drop_index(op.f('ix_product_product_id'), table_name='product')
    op.drop_table('product')
    op.drop_index(op.f('ix_payment_method_method_id'), table_name='payment_method')
    op.drop_table('payment_method')
    op.drop_table('password_reset_token')
    op.drop_index(op.f('ix_cart_session_cart_session_id'), table_name='cart_session')
    op.drop_table('cart_session')
    op.drop_index(op.f('ix_recipe_recipe_id'), table_name='recipe')
    op.drop_table('recipe')
    op.drop_index(op.f('ix_product_category_category_id'), table_name='product_category')
    op.drop_table('product_category')
    op.drop_index(op.f('ix_cart_device_cart_device_id'), table_name='cart_device')
    op.drop_table('cart_device')
    op.drop_index(op.f('ix_app_user_user_id'), table_name='app_user')
    op.drop_table('app_user')
    # ### end Alembic commands ###

----------------------------------------
End of file: alembic\versions\4e8c53bbb5bf_initial_migration.py


Start of file: alembic\versions\5e709302d134_add_camera_view_on_to_cart_session.py
----------------------------------------
"""add camera_view_on to cart_session

Revision ID: 5e709302d134
Revises: e0e8a64d1b86
Create Date: 2026-01-30 10:57:18.611035

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '5e709302d134'
down_revision: Union[str, Sequence[str], None] = 'e0e8a64d1b86'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade():
    op.add_column(
        "cart_session",
        sa.Column(
            "camera_view_on",
            sa.Boolean(),
            server_default=sa.text("false"),
            nullable=False
        )
    )


def downgrade():
    op.drop_column("cart_session", "camera_view_on")
----------------------------------------
End of file: alembic\versions\5e709302d134_add_camera_view_on_to_cart_session.py


Start of file: alembic\versions\82d52c882a35_make_zone_code_and_category_id_not_null.py
----------------------------------------
"""make zone_code and category_id not null

Revision ID: 82d52c882a35
Revises: 5e709302d134
Create Date: 2026-01-30 14:09:57.462673

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '82d52c882a35'
down_revision: Union[str, Sequence[str], None] = '5e709302d134'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('cart_session', 'camera_on')
    op.alter_column('product', 'category_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('product_category', 'zone_code',
               existing_type=sa.VARCHAR(length=30),
               nullable=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('product_category', 'zone_code',
               existing_type=sa.VARCHAR(length=30),
               nullable=True)
    op.alter_column('product', 'category_id',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.add_column('cart_session', sa.Column('camera_on', sa.BOOLEAN(), autoincrement=False, nullable=True))
    # ### end Alembic commands ###

----------------------------------------
End of file: alembic\versions\82d52c882a35_make_zone_code_and_category_id_not_null.py


Start of file: alembic\versions\e0e8a64d1b86_rename_camera_on_to_camera_view_on.py
----------------------------------------
"""rename camera_on to camera_view_on

Revision ID: e0e8a64d1b86
Revises: 3fd7de1c788e
Create Date: 2026-01-30 10:43:43.631679

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'e0e8a64d1b86'
down_revision: Union[str, Sequence[str], None] = '3fd7de1c788e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade():
    op.add_column(
        "cart_session",
        sa.Column("camera_view_on", sa.Boolean(), server_default="false", nullable=False)
    )
    op.drop_column("cart_session", "camera_on")


def downgrade():
    op.add_column(
        "cart_session",
        sa.Column("camera_on", sa.Boolean(), server_default="false", nullable=False)
    )
    op.drop_column("cart_session", "camera_view_on")
----------------------------------------
End of file: alembic\versions\e0e8a64d1b86_rename_camera_on_to_camera_view_on.py


Start of file: app\check_data.py
----------------------------------------
# backend/check_data.py
from sqlalchemy import text
from app.database import SessionLocal
from app import models

def check_db():
    db = SessionLocal()
    try:
        print("====== ğŸ” DB ë°ì´í„° ì ê²€ ======")
        
        # 1. ìƒí’ˆ(Product) í™•ì¸
        products = db.query(models.Product).all()
        print(f"\nğŸ§… [ìƒí’ˆ] ì´ {len(products)}ê°œ")
        for p in products:
            print(f" - ID: {p.product_id}, ì´ë¦„: {p.name}")

        # 2. ë ˆì‹œí”¼(Recipe) í™•ì¸
        recipes = db.query(models.Recipe).all()
        print(f"\nğŸ² [ë ˆì‹œí”¼] ì´ {len(recipes)}ê°œ")
        for r in recipes:
            print(f" - ID: {r.recipe_id}, ì´ë¦„: {r.title}")

        # 3. ì—°ê²°ê³ ë¦¬(RecipeIngredient) í™•ì¸ (ì—¬ê¸°ê°€ í•µì‹¬!)
        links = db.query(models.RecipeIngredient).all()
        print(f"\nğŸ”— [ì—°ê²°] ì´ {len(links)}ê°œ")
        for l in links:
            print(f" - ë ˆì‹œí”¼({l.recipe_id}) <-> ì¬ë£Œ({l.product_id}) | ì ìˆ˜: {l.importance_score}")

        if not links:
            print("\nâŒ ë¬¸ì œ ë°œê²¬: ìƒí’ˆê³¼ ë ˆì‹œí”¼ëŠ” ìˆëŠ”ë° 'ì—°ê²°' ë°ì´í„°ê°€ ì—†ë„¤ìš”!")
            print("   -> seed_data.pyë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤.")
        else:
            print("\nâœ… ë°ì´í„°ëŠ” ì •ìƒì…ë‹ˆë‹¤. product_idë¥¼ ë‹¤ì‹œ í™•ì¸í•´ë³´ì„¸ìš”.")

    except Exception as e:
        print(f"âŒ ì—ëŸ¬ ë°œìƒ: {e}")
    finally:
        db.close()

if __name__ == "__main__":
    check_db()
----------------------------------------
End of file: app\check_data.py


Start of file: app\database.py
----------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.db.base import Base   

SQLALCHEMY_DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+psycopg2://admin:password123@localhost:5432/postgres"
)


connect_args = {}
if "sqlite" in SQLALCHEMY_DATABASE_URL:
    connect_args = {"check_same_thread": False}

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args=connect_args
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

----------------------------------------
End of file: app\database.py


Start of file: app\dependencies.py
----------------------------------------
# app/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import AppUser
from app.utils.jwt import decode_token

security = HTTPBearer()

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db),
) -> AppUser:
    token = credentials.credentials  

    payload = decode_token(token)
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user = db.get(AppUser, int(user_id))
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Inactive user",
        )

    return user


----------------------------------------
End of file: app\dependencies.py


Start of file: app\init_db.py
----------------------------------------
# init_db.py
from sqlalchemy import text
from app.database import SessionLocal

def init_db():
    db = SessionLocal()
    try:
        # 1. ë²¡í„° í™•ì¥ê¸°ëŠ¥ ì¼œê¸°
        print("DBì— ë²¡í„° ê¸°ëŠ¥ì„ ì¼œëŠ” ì¤‘...")
        db.execute(text("CREATE EXTENSION IF NOT EXISTS vector;"))
        db.commit()
        print("âœ… ì„±ê³µ! pgvector ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")

    except Exception as e:
        print(f"âŒ ì—ëŸ¬ ë°œìƒ: {e}")
        print("í˜¹ì‹œ DBê°€ ì¼œì ¸ ìˆëŠ”ì§€, .env ì„¤ì •ì´ ë§ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
    finally:
        db.close()

if __name__ == "__main__":
    init_db()
----------------------------------------
End of file: app\init_db.py


Start of file: app\main.py
----------------------------------------
from dotenv import load_dotenv
load_dotenv() # .env íŒŒì¼ì„ ì°¾ì•„ì„œ í™˜ê²½ë³€ìˆ˜ë¡œ ë¡œë“œí•¨
# ì•± ì‹¤í–‰ ì§„ì…ì 
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .database import engine, Base
from . import models  # ìš°ë¦¬ê°€ ë§Œë“  models.pyë¥¼ ê°€ì ¸ì™€ì•¼ í…Œì´ë¸”ì„ ì¸ì‹í•©ë‹ˆë‹¤!
from .routers import cart, payment, user, auth, product, ledger, recommendation # ë¼ìš°í„° íŒŒì¼ë“¤ ì„í¬íŠ¸

# â˜… í•µì‹¬: ì„œë²„ ì‹œì‘í•  ë•Œ DBì— ì—†ëŠ” í…Œì´ë¸”ì„ ìë™ìœ¼ë¡œ ìƒì„±í•¨
# models.pyì— ì •ì˜ëœ í´ë˜ìŠ¤ë“¤ì„ ë³´ê³  ë§¤í•‘í•©ë‹ˆë‹¤.
# Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Pickle Project API",
    description="ìŠ¤ë§ˆíŠ¸ ì¹´íŠ¸ ë° ì¶”ì²œ/ê²°ì œ ì„œë¹„ìŠ¤ API",
    version="1.0.0"
)

# CORS 
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:8000"],  # ëª¨ë“  ì¶œì²˜ í—ˆìš©
    allow_credentials=True, # ì¿ í‚¤, Authorization í—¤ë”
    allow_methods=["*"],
    allow_headers=["*"],
)

# ë¼ìš°í„° ë“±ë¡ (ë§Œë“¤ì–´ë‘” API ì—°ê²°)
app.include_router(user.router)
app.include_router(auth.router)
app.include_router(product.router)
app.include_router(cart.router)
app.include_router(payment.router)
app.include_router(ledger.router)
app.include_router(recommendation.router)

@app.get("/")
def read_root():
    return {"message": "Hello, Pickle! ì„œë²„ê°€ ì •ìƒ ì‘ë™ ì¤‘ì…ë‹ˆë‹¤."}

@app.get("/health")
def health():
    return {"status": "ok"}
----------------------------------------
End of file: app\main.py


Start of file: app\models.py
----------------------------------------
from sqlalchemy import (
    Column, Integer, String, TIMESTAMP, ForeignKey, DateTime, Boolean, Text, Numeric, Date, Enum as SAEnum
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.postgresql import JSONB
from pgvector.sqlalchemy import Vector
import enum
from app.db.base import Base


# --- Enums (DB Enum Types) ---

class UserProvider(enum.Enum):
    LOCAL = "LOCAL"
    GOOGLE = "GOOGLE"
    KAKAO = "KAKAO"

class CartSessionStatus(enum.Enum):
    ACTIVE = "ACTIVE"
    CHECKOUT_REQUESTED = "CHECKOUT_REQUESTED"
    PAID = "PAID"
    CANCELLED = "CANCELLED"

class DetectionActionType(enum.Enum):
    ADD = "ADD"
    REMOVE = "REMOVE"

class PaymentMethodType(enum.Enum):
    CARD = "CARD"
    KAKAO_PAY = "KAKAO_PAY"

class PgProviderType(enum.Enum):
    KAKAO_PAY = "KAKAO_PAY"
    CARD_PG = "CARD_PG"

class PaymentStatus(enum.Enum):
    PENDING = "PENDING"
    APPROVED = "APPROVED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"

class LedgerCategory(enum.Enum):
    GROCERY = "GROCERY"
    MEAT = "MEAT"
    DAIRY = "DAIRY"
    BEVERAGE = "BEVERAGE"
    SNACK = "SNACK"
    HOUSEHOLD = "HOUSEHOLD"
    ETC = "ETC"

# --- Models ---

class AppUser(Base):
    __tablename__ = "app_user"

    user_id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, nullable=False)
    provider = Column(SAEnum(UserProvider), nullable=False, default=UserProvider.LOCAL)
    nickname = Column(String(40), nullable=False)
    password_hash = Column(String(255))
    created_at = Column(DateTime(timezone=True), nullable=False, default=func.now())
    updated_at = Column(DateTime(timezone=True), default=func.now(), onupdate=func.now())
    is_active = Column(Boolean, nullable=False, default=True)
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    # Relationships
    saved_recipes = relationship("SavedRecipe", back_populates="user", cascade="all, delete-orphan")
    cart_sessions = relationship("CartSession", back_populates="user")
    payment_methods = relationship("PaymentMethod", back_populates="user", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="user")
    ledger_entries = relationship("LedgerEntry", back_populates="user", cascade="all, delete-orphan")


class PasswordResetToken(Base):
    __tablename__ = "password_reset_token"

    token = Column(String, primary_key=True)
    user_id = Column( Integer, ForeignKey("app_user.user_id"), nullable=False)

    expires_at = Column(TIMESTAMP, nullable=False)
    used = Column(Boolean, default=False)

    created_at = Column(TIMESTAMP, server_default=func.now())


class ProductCategory(Base):
    __tablename__ = "product_category"

    category_id = Column(Integer, primary_key=True, index=True)
    name = Column(String(60), unique=True, nullable=False)
    zone_code = Column(String(30), nullable=False)

    # Relationships
    products = relationship("Product", back_populates="category")


class Product(Base):
    __tablename__ = "product"

    product_id = Column(Integer, primary_key=True, index=True)
    category_id = Column(Integer, ForeignKey("product_category.category_id"), nullable=False)
    barcode = Column(String(64), unique=True)
    name = Column(String(255), nullable=False)
    price = Column(Integer, nullable=False)
    unit_weight_g = Column(Integer, nullable=False)
    stock_quantity = Column(Integer, default=0)
    image_url = Column(Text)
    product_info = Column(JSONB)
    embedding = Column(Vector(1536))
    created_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    category = relationship("ProductCategory", back_populates="products")
    cart_items = relationship("CartItem", back_populates="product")
    detection_logs = relationship("CartDetectionLog", back_populates="product")
    recipe_ingredients = relationship("RecipeIngredient", back_populates="product")


class Recipe(Base):
    __tablename__ = "recipe"

    recipe_id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False)
    description = Column(Text)
    instructions = Column(Text)
    image_url = Column(Text)

    embedding = Column(Vector(1536))
    created_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    ingredients = relationship("RecipeIngredient", back_populates="recipe", cascade="all, delete-orphan")
    saved_by_users = relationship("SavedRecipe", back_populates="recipe", cascade="all, delete-orphan")


class RecipeIngredient(Base):
    __tablename__ = "recipe_ingredient"

    recipe_id = Column(Integer, ForeignKey("recipe.recipe_id", ondelete="CASCADE"), primary_key=True)
    product_id = Column(Integer, ForeignKey("product.product_id"), primary_key=True)
    quantity_info = Column(String(50))
    importance_score = Column(Integer, default=1)

    # Relationships
    recipe = relationship("Recipe", back_populates="ingredients")
    product = relationship("Product", back_populates="recipe_ingredients")


class SavedRecipe(Base):
    __tablename__ = "saved_recipe"

    user_id = Column(Integer, ForeignKey("app_user.user_id", ondelete="CASCADE"), primary_key=True)
    recipe_id = Column(Integer, ForeignKey("recipe.recipe_id", ondelete="CASCADE"), primary_key=True)
    saved_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    user = relationship("AppUser", back_populates="saved_recipes")
    recipe = relationship("Recipe", back_populates="saved_by_users")


class CartDevice(Base):
    __tablename__ = "cart_device"

    cart_device_id = Column(Integer, primary_key=True, index=True)
    device_code = Column(String(64), unique=True, nullable=False)

    # Relationships
    sessions = relationship("CartSession", back_populates="device")
    logs = relationship("CartDetectionLog", back_populates="device")


class CartSession(Base):
    __tablename__ = "cart_session"

    cart_session_id = Column(Integer, primary_key=True, index=True)
    cart_device_id = Column(Integer, ForeignKey("cart_device.cart_device_id"), nullable=False)
    user_id = Column(Integer, ForeignKey("app_user.user_id"))
    status = Column(SAEnum(CartSessionStatus), nullable=False, default=CartSessionStatus.ACTIVE)
    budget_limit = Column(Integer, default=0)
    expected_total_g = Column(Integer, default=0)
    measured_total_g = Column(Integer, default=0)
    started_at = Column(DateTime(timezone=True), nullable=False, default=func.now())
    ended_at = Column(DateTime(timezone=True))
    camera_view_on = Column(Boolean, default=False, nullable=False)

    # Relationships
    device = relationship("CartDevice", back_populates="sessions")
    user = relationship("AppUser", back_populates="cart_sessions")
    items = relationship("CartItem", back_populates="session", cascade="all, delete-orphan")
    logs = relationship("CartDetectionLog", back_populates="session", cascade="all, delete-orphan")
    payment = relationship("Payment", uselist=False, back_populates="session")


class CartItem(Base):
    __tablename__ = "cart_item"

    cart_item_id = Column(Integer, primary_key=True, index=True)
    cart_session_id = Column(Integer, ForeignKey("cart_session.cart_session_id", ondelete="CASCADE"), nullable=False)
    product_id = Column(Integer, ForeignKey("product.product_id"), nullable=False)
    quantity = Column(Integer, nullable=False, default=1)
    unit_price = Column(Integer, nullable=False)
    added_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    session = relationship("CartSession", back_populates="items")
    product = relationship("Product", back_populates="cart_items")


class CartDetectionLog(Base):
    __tablename__ = "cart_detection_log"

    log_id = Column(Integer, primary_key=True, index=True)
    cart_session_id = Column(Integer, ForeignKey("cart_session.cart_session_id", ondelete="CASCADE"), nullable=False)
    cart_device_id = Column(Integer, ForeignKey("cart_device.cart_device_id"), nullable=False)
    product_id = Column(Integer, ForeignKey("product.product_id"))
    action_type = Column(SAEnum(DetectionActionType), nullable=False)
    confidence_score = Column(Numeric(5, 2))
    detected_weight_g = Column(Integer)
    is_applied = Column(Boolean, default=False)
    detected_at = Column(DateTime(timezone=True), default=func.now())
    created_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    session = relationship("CartSession", back_populates="logs")
    device = relationship("CartDevice", back_populates="logs")
    product = relationship("Product", back_populates="detection_logs")


class PaymentMethod(Base):
    __tablename__ = "payment_method"

    method_id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("app_user.user_id", ondelete="CASCADE"), nullable=False)
    method_type = Column(SAEnum(PaymentMethodType), nullable=False)
    billing_key = Column(String(255))
    card_brand = Column(String(30))
    card_last4 = Column(String(4))
    is_default = Column(Boolean, nullable=False, default=False)
    created_at = Column(DateTime(timezone=True), default=func.now())

    # Relationships
    user = relationship("AppUser", back_populates="payment_methods")
    payments = relationship("Payment", back_populates="method")


class Payment(Base):
    __tablename__ = "payment"

    payment_id = Column(Integer, primary_key=True, index=True)
    cart_session_id = Column(Integer, ForeignKey("cart_session.cart_session_id"), unique=True)
    user_id = Column(Integer, ForeignKey("app_user.user_id"), nullable=False)
    method_id = Column(Integer, ForeignKey("payment_method.method_id"))
    pg_provider = Column(SAEnum(PgProviderType), nullable=False)
    pg_tid = Column(String(255))
    status = Column(SAEnum(PaymentStatus), nullable=False, default=PaymentStatus.PENDING)
    total_amount = Column(Integer, nullable=False)
    approved_at = Column(DateTime(timezone=True))

    # Relationships
    session = relationship("CartSession", back_populates="payment")
    user = relationship("AppUser", back_populates="payments")
    method = relationship("PaymentMethod", back_populates="payments")
    ledger_entries = relationship("LedgerEntry", back_populates="payment")


class LedgerEntry(Base):
    __tablename__ = "ledger_entry"

    ledger_entry_id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("app_user.user_id", ondelete="CASCADE"), nullable=False)
    payment_id = Column(Integer, ForeignKey("payment.payment_id", ondelete="SET NULL"))
    spend_date = Column(Date, nullable=False)
    category = Column(SAEnum(LedgerCategory), nullable=False, default=LedgerCategory.ETC)
    amount = Column(Integer, nullable=False)
    memo = Column(Text)

    # Relationships
    user = relationship("AppUser", back_populates="ledger_entries")
    payment = relationship("Payment", back_populates="ledger_entries")

----------------------------------------
End of file: app\models.py


Start of file: app\schemas.py
----------------------------------------
from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from .models import PaymentMethodType, PgProviderType, PaymentStatus, LedgerCategory, DetectionActionType, UserProvider
import re

# =========================================================
# ğŸ’³ Payment Method Schemas (ê²°ì œ ìˆ˜ë‹¨)
# =========================================================

class PaymentMethodBase(BaseModel):
    method_type: PaymentMethodType
    billing_key: Optional[str] = None
    card_brand: Optional[str] = None
    card_last4: Optional[str] = Field(None, min_length=4, max_length=4)
    is_default: bool = False

class PaymentMethodCreate(PaymentMethodBase):
    pass

class PaymentMethodResponse(PaymentMethodBase):
    method_id: int
    user_id: int
    created_at: datetime

    class Config:
        from_attributes = True


# =========================================================
# ğŸ’° Payment Schemas (ê²°ì œ)
# =========================================================

# 1. ê²°ì œ ì¤€ë¹„ (Ready)
class PaymentReadyRequest(BaseModel):
    cart_session_id: int
    total_amount: int = Field(..., gt=0, description="ê²°ì œ ê¸ˆì•¡ì€ 0ì› ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.") 
    method_id: Optional[int] = None

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "cart_session_id": 12,
            "total_amount": 15000,
            "method_id": None
        }
    })

class PaymentReadyResponse(BaseModel):
    tid: str
    next_redirect_app_url: Optional[str] = None
    next_redirect_mobile_url: Optional[str] = None
    next_redirect_pc_url: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.now)
    partner_order_id: Optional[str] = None

# 2. ê²°ì œ ìŠ¹ì¸ (Approve)
class PaymentApproveRequest(BaseModel):
    tid: str
    pg_token: str
    partner_order_id: str
    partner_user_id: str

# 3. ê²°ì œ ë‚´ì—­ ì‘ë‹µ
class PaymentResponse(BaseModel):
    payment_id: int
    cart_session_id: Optional[int]
    user_id: int
    method_id: Optional[int]
    pg_provider: PgProviderType
    pg_tid: Optional[str]
    status: PaymentStatus
    total_amount: int
    approved_at: Optional[datetime]

    class Config:
        from_attributes = True

# 4. ê²°ì œ ì·¨ì†Œ
class PaymentCancelRequest(BaseModel):
    reason: str = "ì‚¬ìš©ì ìš”ì²­ì— ì˜í•œ ì·¨ì†Œ"

class PaymentDetailResponse(PaymentResponse):
    pass

# --- âœ¨ [NEW] ê²°ì œ ìš”ì²­ ë° ë¬´ê²Œ ê²€ì¦ (Checkout) ---

class PaymentRequest(BaseModel):
    """ì›¹ì—ì„œ ê²°ì œí•˜ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ ì „ì†¡í•˜ëŠ” ë°ì´í„°"""
    cart_session_id: int
    amount: int
    measured_weight_g: int = Field(..., description="Jetson/ì„¼ì„œë¡œë¶€í„° ì¸¡ì •í•œ í˜„ì¬ ë¬´ê²Œ")
    use_subscription: bool = True  # ê¸°ë³¸ì ìœ¼ë¡œ ìë™ê²°ì œ ì‚¬ìš©

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "cart_session_id": 5,
            "amount": 25000,
            "measured_weight_g": 1500,
            "use_subscription": True
        }
    })

class PaymentWarningResponse(BaseModel):
    """ë¬´ê²Œ ë¶ˆì¼ì¹˜ ì‹œ ë°˜í™˜í•˜ëŠ” ê²½ê³  ë°ì´í„° (409 Conflict)"""
    status: str = "WARNING"
    message: str
    difference: int
    expected_weight: int
    measured_weight: int
    action_required: str = "CHECK_CART_ITEMS"  # í”„ë¡ íŠ¸ì—”ë“œ ì‹ë³„ìš©


# =========================================================
# ğŸ”‘ Billing Key Schemas (ì¹´ë“œ ë“±ë¡)
# =========================================================

class CardRegisterResponse(BaseModel):
    next_redirect_mobile_url: str
    next_redirect_pc_url: str
    tid: str
    created_at: datetime

class CardRegisterResult(BaseModel):
    method_id: int
    card_name: str
    billing_key: str
    message: str = "ì¹´ë“œ ë“±ë¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."


# =========================================================
# ğŸ“’ Ledger Schemas (ê°€ê³„ë¶€)
# =========================================================

class LedgerEntryResponse(BaseModel):
    ledger_entry_id: int
    user_id: int
    payment_id: Optional[int]
    spend_date: date
    category: LedgerCategory
    amount: int
    memo: Optional[str]

    class Config:
        from_attributes = True

class LedgerUpdateRequest(BaseModel):
    category: Optional[LedgerCategory] = None
    memo: Optional[str] = None

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "category": "SNACK",
            "memo": "í¸ì˜ì  ê°„ì‹ êµ¬ë§¤"
        }
    })


# =========================================================
# ğŸ‘¤ User Schemas (íšŒì›)
# =========================================================

NICKNAME_REGEX = re.compile(r"^[A-Za-zê°€-í£]{2,20}$")

class UserBase(BaseModel):
    email: EmailStr
    nickname: str = Field(min_length=2, max_length=20)

class UserCreate(BaseModel):
    email: EmailStr
    password: str
    nickname: str

    @field_validator("password")
    @classmethod
    def validate_password(cls, value: str) -> str:
        if len(value) < 8:
            raise ValueError("Password must be at least 8 characters long")
        if not re.search(r"[A-Za-z]", value) or not re.search(r"\d", value):
            raise ValueError("Password must contain both letters and numbers")
        return value

    @field_validator("nickname")
    @classmethod
    def validate_nickname(cls, value: str) -> str:
        if not NICKNAME_REGEX.fullmatch(value):
            raise ValueError("Nickname must be 2â€“20 characters long and contain only Korean or English letters")
        return value
    
    model_config = ConfigDict(json_schema_extra={
        "example": {
            "email": "user@example.com",
            "password": "Password123!",
            "nickname": "í–‰ë³µí•œì‡¼í•‘"
        }
    })

class UserLogin(BaseModel):
    email: EmailStr
    password: str

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "email": "user@example.com",
            "password": "Password123!"
        }
    })

class UserMeResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    user_id: int
    email: EmailStr
    provider: UserProvider
    nickname: str
    created_at: datetime
    updated_at: Optional[datetime]

class UserNicknameUpdate(BaseModel):
    nickname: str = Field(min_length=2, max_length=20)

class UserPasswordUpdate(BaseModel):
    current_password: str
    new_password: str

class UserPasswordResetRequest(BaseModel):
    email: EmailStr

class UserPasswordReset(BaseModel):
    token: str
    new_password: str = Field(min_length=8)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class EmailCheckResponse(BaseModel):
    is_available: bool

class UserWithdraw(BaseModel):
    password: Optional[str] = None

class GoogleOAuthRequest(BaseModel):
    code: str


# =========================================================
# ğŸ›’ Cart Schemas (ì¥ë°”êµ¬ë‹ˆ)
# =========================================================

class CartItemCreate(BaseModel):
    product_id: int
    quantity: int = Field(default=1, ge=1)

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "product_id": 101,
            "quantity": 2
        }
    })

class ProductSimpleResponse(BaseModel):
    product_id: int
    name: str
    price: int
    image_url: Optional[str] = None
    
    class Config:
        from_attributes = True

class CartItemResponse(BaseModel):
    cart_item_id: int
    product: ProductSimpleResponse
    quantity: int
    unit_price: int
    total_price: int
    
    class Config:
        from_attributes = True

class CartSessionResponse(BaseModel):
    cart_session_id: int
    status: str
    total_amount: int
    total_items: int = 0
    expected_total_g: int = 0
    items: List[CartItemResponse] = Field(default_factory=list)
    
    class Config:
        from_attributes = True

class CartItemUpdate(BaseModel):
    quantity: int = Field(..., ge=1)

# --- Cart Weight Validation ---
class CartWeightValidateRequest(BaseModel):
    cart_session_id: int
    measured_weight_g: int = Field(..., gt=0)

    model_config = ConfigDict(json_schema_extra={
        "example": {
            "cart_session_id": 5,
            "measured_weight_g": 520
        }
    })

class CartWeightValidateResponse(BaseModel):
    is_valid: bool
    status: str  # MATCH | OVER_WEIGHT | UNDER_WEIGHT
    expected_weight: int
    measured_weight: int
    difference: int
    tolerance: int
    message: str


# =========================================================
# ğŸ³ Recipe & Product Schemas (ì¶”ì²œ ë° ìƒí’ˆ)
# =========================================================

class IngredientSimpleResponse(BaseModel):
    product_id: int
    name: str
    is_owned: bool
    
    class Config:
        from_attributes = True

class RecipeRecommendResponse(BaseModel):
    recipe_id: int
    title: str
    description: Optional[str] = None
    image_url: Optional[str] = None
    
    # AI ì¶”ì²œ ì ìˆ˜
    similarity_score: Optional[float] = None
    
    # ì¬ë£Œ ë¶„ì„
    missing_ingredients: List[IngredientSimpleResponse] = []
    
    class Config:
        from_attributes = True

class ProductResponse(BaseModel):
    product_id: int
    name: str
    price: int
    stock_quantity: Optional[int] = 0
    image_url: Optional[str] = None
    product_info: Optional[Dict[str, Any]] = None

    class Config:
        from_attributes = True
----------------------------------------
End of file: app\schemas.py


Start of file: app\seed_data.py
----------------------------------------
import datetime
import sys
import os
from dotenv import load_dotenv

# Add parent directory to path to allow importing 'app'
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Load environment variables
load_dotenv(os.path.join(os.path.dirname(__file__), '../.env'))

from sqlalchemy import text  # â˜… ì´ ì¤„ ê¼­ ì¶”ê°€í•˜ì„¸ìš”!
from app.database import SessionLocal, engine
from app import models

def init_data():
    # â˜… [í•µì‹¬] DBì— ë²¡í„° ê¸°ëŠ¥ì„ ê°•ì œë¡œ ì¼­ë‹ˆë‹¤.
    try:
        with engine.connect() as conn:
            conn.execute(text("CREATE EXTENSION IF NOT EXISTS vector"))
            conn.commit()
            print("âœ… pgvector ê¸°ëŠ¥ í™œì„±í™” ì™„ë£Œ!")
    except Exception as e:
        print(f"âš ï¸ ë²¡í„° ê¸°ëŠ¥ í™œì„±í™” ê²½ê³ : {e}")

    # 1. í…Œì´ë¸” ìƒì„±
    models.Base.metadata.create_all(bind=engine)
    
    db = SessionLocal()
    try:
        print("ğŸŒ± ë°ì´í„° ì‹¬ëŠ” ì¤‘...")

        # 2. í…ŒìŠ¤íŠ¸ ìœ ì € ìƒì„±
        user = models.AppUser(user_id=1, email="test@test.com", nickname="í…ŒìŠ¤íŠ¸ìœ ì €", provider="LOCAL")
        db.merge(user)

        # 3. ìƒí’ˆ ìƒì„± (ì–‘íŒŒ)
        onion = models.Product(product_id=100, name="ì–‘íŒŒ", price=500, unit_weight_g=200)
        db.merge(onion)

        # 4. ë ˆì‹œí”¼ ìƒì„± (ì–‘íŒŒìˆ˜í”„)
        soup = models.Recipe(recipe_id=501, title="í”„ë Œì¹˜ ì–´ë‹ˆì–¸ ìˆ˜í”„", description="ì–‘íŒŒê°€ ë“¬ë¿ ë“¤ì–´ê°„ ìˆ˜í”„")
        db.merge(soup)

        # 5. ìƒí’ˆ-ë ˆì‹œí”¼ ì—°ê²° (ê°€ì¤‘ì¹˜ 5ì !)
        link = models.RecipeIngredient(recipe_id=501, product_id=100, importance_score=5, quantity_info="2ê°œ")
        db.merge(link)
        
        # 6. ì¹´íŠ¸ ê¸°ê¸° & ì„¸ì…˜ ìƒì„±
        device = models.CartDevice(cart_device_id=99, device_code="CART_001")
        db.merge(device)
        
        session = models.CartSession(
            cart_session_id=1, 
            cart_device_id=99, 
            user_id=1, 
            status=models.CartSessionStatus.ACTIVE
        )
        db.merge(session)

        db.commit()
        print("âœ… ê¸°ì´ˆ ë°ì´í„° ìƒì„± ì™„ë£Œ! (User:1, Product:100, Session:1)")

    except Exception as e:
        print(f"âŒ ì—ëŸ¬ ë°œìƒ: {e}")
        db.rollback()
    finally:
        db.close()

if __name__ == "__main__":
    init_data()
----------------------------------------
End of file: app\seed_data.py


Start of file: app\__init__.py
----------------------------------------

----------------------------------------
End of file: app\__init__.py


Start of file: app\core\config.py
----------------------------------------
import os
from dotenv import load_dotenv
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸(S14P11A202/) í´ë”ë¥¼ ê¸°ì¤€ìœ¼ë¡œ .env íŒŒì¼ì„ ì°¾ìŠµë‹ˆë‹¤.
# app/core/config.py -> parent(1): app/core -> parent(2): app -> parent(3): backend -> parent(4): í”„ë¡œì íŠ¸ ë£¨íŠ¸
BASE_DIR = Path(__file__).resolve().parent.parent.parent.parent
load_dotenv(BASE_DIR / ".env")


class Settings:
    DATABASE_URL = os.getenv("DATABASE_URL")
    GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
    GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
    GOOGLE_REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI")
    KAKAO_REST_API_KEY = os.getenv("KAKAO_REST_API_KEY")
    KAKAO_REDIRECT_URI = os.getenv("KAKAO_REDIRECT_URI") 
    JETSON_BASE_URL = os.getenv("JETSON_BASE_URL")
    JETSON_STREAM_URL = os.getenv("JETSON_STREAM_URL")

settings = Settings()




----------------------------------------
End of file: app\core\config.py


Start of file: app\db\base.py
----------------------------------------
from sqlalchemy.orm import declarative_base

Base = declarative_base()

----------------------------------------
End of file: app\db\base.py


Start of file: app\routers\auth.py
----------------------------------------
# app/routers/auth.py
from fastapi import APIRouter, Cookie, HTTPException, Depends, status
from app.utils.jwt import decode_token, create_access_token, create_refresh_token
from sqlalchemy.orm import Session

from app.schemas import UserPasswordResetRequest, UserPasswordReset
from app.database import get_db
from app.models import AppUser, PasswordResetToken, UserProvider
from app.utils.security import hash_password

import uuid
from datetime import datetime, timedelta
from app.utils.email import send_reset_password_email
from os import getenv

import requests
from app import models, schemas
from app.core.config import settings   # settingsì—ì„œ env ì½ëŠ” êµ¬ì¡°ì¼ ë•Œ

from fastapi import Query
from fastapi.responses import JSONResponse, RedirectResponse

router = APIRouter(prefix="/auth", tags=["auth"])


@router.post("/refresh")
def refresh_access_token(refresh_token: str = Cookie(None)):
    if not refresh_token:
        raise HTTPException(status_code=401, detail="Refresh token missing")

    payload = decode_token(refresh_token)

    if payload.get("type") != "refresh":
        raise HTTPException(status_code=401, detail="Invalid token type")

    new_access_token = create_access_token(payload["sub"])

    return {
        "access_token": new_access_token,
        "token_type": "bearer",
    }


# TODO: SMTP blocked in SSAFY network
# TODO: Replace with SendGrid (HTTP API)

# ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ìš”ì²­ API
@router.post("/password/reset-request")
def request_password_reset(
    request: UserPasswordResetRequest,
    db: Session = Depends(get_db)
):
    user = db.query(AppUser).filter(AppUser.email == request.email).first()

    if not user:
        raise HTTPException(
            status_code=404,
            detail="í•´ë‹¹ ì´ë©”ì¼ë¡œ ê°€ì…ëœ íšŒì›ì´ ì—†ìŠµë‹ˆë‹¤."
        )

    reset_token = str(uuid.uuid4())
    expires_at = datetime.utcnow() + timedelta(minutes=30)

    token_row = PasswordResetToken(
        token=reset_token,
        user_id=user.user_id,
        expires_at=expires_at,
        used=False
    )

    db.add(token_row)
    db.commit()

    reset_link = f"{getenv('FRONTEND_URL')}/reset-password?token={reset_token}"
    send_reset_password_email(user.email, reset_link)

    return {"message": "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì´ë©”ì¼ì„ ì „ì†¡í–ˆìŠµë‹ˆë‹¤."}


# ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì‹¤í–‰ API
@router.post("/password/reset")
def reset_password(
    request: UserPasswordReset,
    db: Session = Depends(get_db)
):
    token_row = (
        db.query(PasswordResetToken)
        .filter(PasswordResetToken.token == request.token)
        .first()
    )

    if not token_row:
        raise HTTPException(status_code=400, detail="ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤.")

    if token_row.used:
        raise HTTPException(status_code=400, detail="ì´ë¯¸ ì‚¬ìš©ëœ í† í°ì…ë‹ˆë‹¤.")

    if token_row.expires_at < datetime.utcnow():
        raise HTTPException(status_code=400, detail="í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    user = (
        db.query(AppUser)
        .filter(AppUser.user_id == token_row.user_id)
        .first()
    )

    user.password_hash = hash_password(request.new_password)
    token_row.used = True

    db.commit()

    return {"message": "ë¹„ë°€ë²ˆí˜¸ê°€ ì„±ê³µì ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤."}


# êµ¬ê¸€ ë¡œê·¸ì¸
@router.post(
    "/google",
    response_model=schemas.TokenResponse,
)
def google_login(
    request: schemas.GoogleOAuthRequest,
    db: Session = Depends(get_db),
):
    # 1. code â†’ access token
    token_res = requests.post(
        "https://oauth2.googleapis.com/token",
        data={
            "client_id": settings.GOOGLE_CLIENT_ID,
            "client_secret": settings.GOOGLE_CLIENT_SECRET,
            "code": request.code,
            "grant_type": "authorization_code",
            "redirect_uri": settings.GOOGLE_REDIRECT_URI,
        },
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )

    if token_res.status_code != 200:
        raise HTTPException(
            status_code=400,
            detail="Google token exchange failed",
        )

    google_access_token = token_res.json().get("access_token")

    # 2. ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    user_res = requests.get(
        "https://www.googleapis.com/oauth2/v2/userinfo",
        headers={
            "Authorization": f"Bearer {google_access_token}"
        },
    )

    user_info = user_res.json()

    email = user_info.get("email")
    nickname = user_info.get("name")

    if not email:
        raise HTTPException(
            status_code=400,
            detail="Google user info invalid",
        )

    # 3. ì‚¬ìš©ì ì¡°íšŒ
    user = (
        db.query(models.AppUser)
        .filter(
            models.AppUser.email == email,
            models.AppUser.provider == "GOOGLE",
        )
        .first()
    )

    # 4. ì—†ìœ¼ë©´ íšŒì›ê°€ì…
    if not user:
        user = models.AppUser(
            email=email,
            nickname=nickname,
            provider="GOOGLE",
            password_hash=None,
        )
        db.add(user)
        db.commit()
        db.refresh(user)

    # 5. JWT ë°œê¸‰
    access_token = create_access_token(str(user.user_id))
    refresh_token = create_refresh_token(str(user.user_id))

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
    }


@router.get("/google/callback")
def google_callback(
    code: str = Query(...),
    db: Session = Depends(get_db),
):
    """
    Google OAuth redirect endpoint (í”„ë¡ íŠ¸ ë¯¸êµ¬í˜„ìš©)
    """
    # ê¸°ì¡´ POST /auth/google ë¡œì§ì„ ê·¸ëŒ€ë¡œ ì¬ì‚¬ìš©
    oauth_request = schemas.GoogleOAuthRequest(code=code)
    return google_login(oauth_request, db)


# ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸
@router.get("/kakao/login")
def kakao_login():
    kakao_auth_url = (
        "https://kauth.kakao.com/oauth/authorize"
        f"?client_id={settings.KAKAO_REST_API_KEY}"
        f"&redirect_uri={settings.KAKAO_REDIRECT_URI}"
        "&response_type=code"
    )
    return RedirectResponse(kakao_auth_url)


@router.get("/kakao/callback")
def kakao_callback(
    code: str,
    db: Session = Depends(get_db),
):
    # 1. í† í° ìš”ì²­
    token_res = requests.post(
        "https://kauth.kakao.com/oauth/token",
        data={
            "grant_type": "authorization_code",
            "client_id": settings.KAKAO_REST_API_KEY,
            "redirect_uri": settings.KAKAO_REDIRECT_URI,
            "code": code,
        },
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )

    if token_res.status_code != 200:
        print("Kakao token error:", token_res.text)
        raise HTTPException(status_code=400, detail=token_res.text)

    access_token = token_res.json()["access_token"]

    # 2. ì‚¬ìš©ì ì •ë³´
    user_res = requests.get(
        "https://kapi.kakao.com/v2/user/me",
        headers={"Authorization": f"Bearer {access_token}"},
    )

    kakao_user = user_res.json()

    kakao_id = kakao_user["id"]
    nickname = kakao_user["properties"]["nickname"]

    email = None
    if "kakao_account" in kakao_user:
        email = kakao_user["kakao_account"].get("email")

    # 3. DB ì¡°íšŒ
    user = (
        db.query(AppUser)
        .filter(
            AppUser.provider == UserProvider.KAKAO,
            AppUser.email == (email or f"kakao_{kakao_id}@kakao.com"),
        )
        .first()
    )

    # 4. ì—†ìœ¼ë©´ íšŒì›ê°€ì…
    if not user:
        user = AppUser(
            email=email or f"kakao_{kakao_id}@kakao.com",
            nickname=nickname,
            provider=UserProvider.KAKAO,
            password_hash=None,
        )
        db.add(user)
        db.commit()
        db.refresh(user)

    # 5. JWT ë°œê¸‰
    access_token = create_access_token(str(user.user_id))
    refresh_token = create_refresh_token(str(user.user_id))

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
    }


----------------------------------------
End of file: app\routers\auth.py


Start of file: app\routers\cart.py
----------------------------------------
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from .. import models, schemas, database
from ..dependencies import get_current_user 
from sqlalchemy.sql import func 
import requests
from app.core.config import settings
from datetime import datetime
import uuid


from app.schemas import (
    CartWeightValidateRequest,
    CartWeightValidateResponse
)
from app.utils.check_data import validate_cart_weight

router = APIRouter(
    prefix="/api/carts",
    tags=["carts"],
    responses={404: {"description": "Not found"}},
)

# QR pair
@router.post("/pair/qr")
def pair_cart_by_qr(
    device_code: str,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    # 1. ë””ë°”ì´ìŠ¤ ì¡°íšŒ (QR ê¸°ë°˜)
    device = (
        db.query(models.CartDevice)
        .filter(models.CartDevice.device_code == device_code)
        .first()
    )

    if not device:
        raise HTTPException(status_code=404, detail="ì¹´íŠ¸ ë””ë°”ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # 2. í•´ë‹¹ ë””ë°”ì´ìŠ¤ì˜ ACTIVE ì„¸ì…˜ ì¡°íšŒ
    session = (
        db.query(models.CartSession)
        .filter(
            models.CartSession.cart_device_id == device.cart_device_id,
            models.CartSession.status == models.CartSessionStatus.ACTIVE,
        )
        .order_by(models.CartSession.started_at.desc())
        .first()
    )

    # 3. ì—†ìœ¼ë©´ ìƒˆ ì„¸ì…˜ ìƒì„±
    if not session:
        session = models.CartSession(
            cart_device_id=device.cart_device_id,
            user_id=current_user.user_id,
            status=models.CartSessionStatus.ACTIVE,
        )
        db.add(session)
        db.commit()
        db.refresh(session)
    else:
        # 4. ìˆìœ¼ë©´ ì‚¬ìš©ìë§Œ ì—°ê²°
        session.user_id = current_user.user_id
        db.commit()

    return {
        "cart_session_id": session.cart_session_id,
        "cart_device_id": device.cart_device_id,
        "message": "ì¹´íŠ¸ê°€ ì•±ê³¼ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.",
    }


# --- 1. ì¥ë°”êµ¬ë‹ˆ ìƒì„± (ì‡¼í•‘ ì‹œì‘) ---
@router.post("/", response_model=schemas.CartSessionResponse)
def create_cart_session(
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    ìƒˆë¡œìš´ ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.
    """
    new_session = models.CartSession(
        user_id=current_user.user_id,
        status=models.CartSessionStatus.ACTIVE,
        cart_device_id=1  # í…ŒìŠ¤íŠ¸ìš© ì„ì‹œ ë””ë°”ì´ìŠ¤ ID
    )
    db.add(new_session)
    db.commit()
    db.refresh(new_session)
    
    # ë¹ˆ ì¥ë°”êµ¬ë‹ˆ ë°˜í™˜
    return {
        "cart_session_id": new_session.cart_session_id,
        "status": new_session.status.value,
        "total_amount": 0,
        "total_items": 0,
        "items": [],
        "expected_total_g": 0
    }


# --- 2. ì¥ë°”êµ¬ë‹ˆ ì¡°íšŒ ---
@router.get("/{session_id}", response_model=schemas.CartSessionResponse)
def get_cart_session(
    session_id: int, 
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    # ì„¸ì…˜ ë³¸ì¸ í™•ì¸
    session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == session_id,
        models.CartSession.user_id == current_user.user_id
    ).first()

    if not session:
        raise HTTPException(status_code=404, detail="ì¥ë°”êµ¬ë‹ˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    # ìƒí’ˆ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    cart_items = db.query(models.CartItem).filter(
        models.CartItem.cart_session_id == session_id
    ).all()

    response_items = []
    total_amount = 0
    total_quantity = 0

    for item in cart_items:
        item_total = item.unit_price * item.quantity
        total_amount += item_total
        total_quantity += item.quantity
        
        response_items.append({
            "cart_item_id": item.cart_item_id,
            "product": item.product, 
            "quantity": item.quantity,
            "unit_price": item.unit_price,
            "total_price": item_total 
        })

    return {
        "cart_session_id": session.cart_session_id,
        "status": session.status.value, 
        "total_amount": total_amount,
        "total_items": total_quantity,
        "items": response_items,        
        "expected_total_g": session.expected_total_g
    }


# --- 3. ì¥ë°”êµ¬ë‹ˆì— ìƒí’ˆ ë‹´ê¸° ---
@router.post("/{session_id}/items")
def add_cart_item(
    session_id: int,
    item_req: schemas.CartItemCreate,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    # ì„¸ì…˜ ë³¸ì¸ í™•ì¸
    session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == session_id,
        models.CartSession.user_id == current_user.user_id
    ).first()
    if not session:
        raise HTTPException(status_code=404, detail="ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")

    # ìƒí’ˆ ì¡´ì¬ í™•ì¸
    product = db.query(models.Product).filter(models.Product.product_id == item_req.product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="ìƒí’ˆì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

    # ì´ë¯¸ ë‹´ê¸´ ìƒí’ˆì¸ì§€ í™•ì¸
    existing_item = db.query(models.CartItem).filter(
        models.CartItem.cart_session_id == session_id,
        models.CartItem.product_id == item_req.product_id
    ).first()

    if existing_item:
        existing_item.quantity += item_req.quantity
    else:
        db.add(models.CartItem(
            cart_session_id=session_id,
            product_id=item_req.product_id,
            quantity=item_req.quantity,
            unit_price=product.price
        ))

    db.flush()                      
    recalc_expected_weight(session) 
    db.commit()
    
    return {"message": "ì¥ë°”êµ¬ë‹ˆì— ìƒí’ˆì„ ë‹´ì•˜ìŠµë‹ˆë‹¤."}


# --- ìš”ë¦¬ ì„ íƒ ---
@router.post("/{session_id}/select-recipe")
def select_recipe(session_id: int, recipe_id: int, db: Session = Depends(database.get_db)):
    session = db.query(models.CartSession).filter(models.CartSession.cart_session_id == session_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    # ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ ì„¸ì…˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    return {"detail": f"ë ˆì‹œí”¼(ID:{recipe_id})ê°€ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤."}


# ì˜ˆìƒ ë¬´ê²Œ ê³„ì‚°
def recalc_expected_weight(session: models.CartSession):
    total_weight = 0
    for item in session.items:
        unit_weight = item.product.unit_weight_g or 0
        total_weight += unit_weight * item.quantity
    session.expected_total_g = total_weight


# ìƒí’ˆ ì‚­ì œ
@router.delete("/items/{cart_item_id}")
def delete_cart_item(
    cart_item_id: int,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    cart_item = (
        db.query(models.CartItem)
        .join(models.CartSession)
        .filter(
            models.CartItem.cart_item_id == cart_item_id,
            models.CartSession.user_id == current_user.user_id
        )
        .first()
    )

    if not cart_item:
        raise HTTPException(status_code=404, detail="ì¹´íŠ¸ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    session = cart_item.session

    if session.status != models.CartSessionStatus.ACTIVE:
        raise HTTPException(status_code=400, detail="ìˆ˜ì • ê°€ëŠ¥í•œ ì¹´íŠ¸ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤.")

    db.delete(cart_item)
    db.flush()

    recalc_expected_weight(session)

    db.commit()

    return {
        "message": "ìƒí’ˆì´ ì¹´íŠ¸ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.",
        "expected_total_g": session.expected_total_g
    }

# ìƒí’ˆ ìˆ˜ëŸ‰ ë³€ê²½
@router.patch("/items/{cart_item_id}")
def update_cart_item_quantity(
    cart_item_id: int,
    req: schemas.CartItemUpdate,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    # 1. ì¹´íŠ¸ ìƒí’ˆ + ì‚¬ìš©ì ì†Œìœ  í™•ì¸
    cart_item = (
        db.query(models.CartItem)
        .join(models.CartSession)
        .filter(
            models.CartItem.cart_item_id == cart_item_id,
            models.CartSession.user_id == current_user.user_id
        )
        .first()
    )

    if not cart_item:
        raise HTTPException(status_code=404, detail="ì¹´íŠ¸ ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    session = cart_item.session

    # 2. ì¹´íŠ¸ ìƒíƒœ í™•ì¸
    if session.status != models.CartSessionStatus.ACTIVE:
        raise HTTPException(status_code=400, detail="ìˆ˜ì • ê°€ëŠ¥í•œ ì¹´íŠ¸ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤.")

    # 3. ìˆ˜ëŸ‰ ë³€ê²½
    cart_item.quantity = req.quantity

    db.flush()  # ë³€ê²½ì‚¬í•­ ë°˜ì˜

    # 4. ì˜ˆìƒ ë¬´ê²Œ ì¬ê³„ì‚°
    recalc_expected_weight(session)

    db.commit()
    db.refresh(cart_item)

    return {
        "message": "ìƒí’ˆ ìˆ˜ëŸ‰ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.",
        "cart_item_id": cart_item.cart_item_id,
        "quantity": cart_item.quantity,
        "expected_total_g": session.expected_total_g
    }

# ë¬´ê²Œ ê²€ì¦
@router.post("/weight/validate", response_model=CartWeightValidateResponse)
def validate_weight(
    request: CartWeightValidateRequest,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == request.cart_session_id,
        models.CartSession.user_id == current_user.user_id
    ).first()

    if not session:
        raise HTTPException(status_code=404, detail="ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    result = validate_cart_weight(
        db=db,
        cart_session_id=request.cart_session_id,
        measured_weight_g=request.measured_weight_g
    )

    db.commit()
    return result


# --- ì¹´íŠ¸ ì„¸ì…˜ ì·¨ì†Œ ---
@router.post("/{session_id}/cancel")
def cancel_cart_session(
    session_id: int,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == session_id,
        models.CartSession.user_id == current_user.user_id
    ).first()

    if not session:
        raise HTTPException(status_code=404, detail="ì¹´íŠ¸ ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    if session.status != models.CartSessionStatus.ACTIVE:
        raise HTTPException(
            status_code=400,
            detail="ì·¨ì†Œ ê°€ëŠ¥í•œ ì¹´íŠ¸ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤."
        )

    session.status = models.CartSessionStatus.CANCELLED
    session.ended_at = func.now()

    db.commit()

    return {
        "message": "ì¹´íŠ¸ ì„¸ì…˜ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.",
        "cart_session_id": session.cart_session_id,
        "status": session.status.value
    }

# ì¹´ë©”ë¼ ë·° on
@router.post("/{cart_session_id}/camera/view/on")
def camera_view_on(
    cart_session_id: int,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    cart = (
        db.query(models.CartSession)
        .filter(
            models.CartSession.cart_session_id == cart_session_id,
            models.CartSession.user_id == current_user.user_id,
            models.CartSession.status == models.CartSessionStatus.ACTIVE,
        )
        .first()
    )

    if not cart:
        raise HTTPException(status_code=404, detail="Active cart not found")

    cart.camera_view_on = True
    db.commit()

    return {
        "cart_session_id": cart_session_id,
        "camera_view_on": True,
        "stream_url": settings.JETSON_STREAM_URL
    }


# camera view close
@router.post("/{cart_session_id}/camera/view/off")
def camera_view_off(
    cart_session_id: int,
    db: Session = Depends(database.get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    cart = (
        db.query(models.CartSession)
        .filter(
            models.CartSession.cart_session_id == cart_session_id,
            models.CartSession.user_id == current_user.user_id,
            models.CartSession.status == models.CartSessionStatus.ACTIVE,
        )
        .first()
    )

    if not cart:
        raise HTTPException(status_code=404, detail="Active cart not found")

    cart.camera_view_on = False
    db.commit()

    return {
        "cart_session_id": cart_session_id,
        "camera_view_on": False
    }

----------------------------------------
End of file: app\routers\cart.py


Start of file: app\routers\ledger.py
----------------------------------------
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from datetime import date
from typing import Optional

from app.database import get_db
from app import models
from app.dependencies import get_current_user
from app.schemas import LedgerUpdateRequest

from sqlalchemy import func
from calendar import monthrange





router = APIRouter(
    prefix="/api/ledger",
    tags=["ledger"],
)

# ======================================================
# 1ï¸âƒ£ ê²°ì œ â†’ ê°€ê³„ë¶€ ìƒì„± (payment ìŠ¹ì¸ ê¸°ë°˜)
# ======================================================
@router.post("/from-payment/{payment_id}")
def create_ledger_from_payment(
    payment_id: int,
    db: Session = Depends(get_db),
):
    # payment ì¡°íšŒ (CartSession, Itemsê¹Œì§€ í•¨ê»˜ ë¡œë”©í•˜ë ¤ë©´ join í•„ìš”í•  ìˆ˜ ìˆìŒ)
    payment = db.query(models.Payment).filter(
        models.Payment.payment_id == payment_id
    ).first()

    if not payment:
        raise HTTPException(status_code=404, detail="ê²°ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    if payment.status != models.PaymentStatus.APPROVED:
        raise HTTPException(
            status_code=400,
            detail="ìŠ¹ì¸ëœ ê²°ì œë§Œ ê°€ê³„ë¶€ë¡œ ë“±ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
        )

    # ì´ë¯¸ ledger ìˆëŠ”ì§€ í™•ì¸
    existing = db.query(models.LedgerEntry).filter(
        models.LedgerEntry.payment_id == payment_id
    ).first()

    if existing:
        raise HTTPException(
            status_code=409,
            detail="ì´ë¯¸ ê°€ê³„ë¶€ì— ë“±ë¡ëœ ê²°ì œì…ë‹ˆë‹¤."
        )

    # --- ì¹´í…Œê³ ë¦¬ ìë™ ë§¤í•‘ ë¡œì§ ì‹œì‘ ---
    
    # 1. ê²°ì œì™€ ì—°ê²°ëœ ì¹´íŠ¸ ì„¸ì…˜ ì°¾ê¸°
    cart_session = payment.session
    if not cart_session:
        # ì„¸ì…˜ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
        main_category = models.LedgerCategory.GROCERY
        memo_text = "ì¹´ì¹´ì˜¤í˜ì´ ê²°ì œ (ì„¸ì…˜ ì •ë³´ ì—†ìŒ)"
    else:
        # 2. ì¹´íŠ¸ ì•„ì´í…œ ìˆœíšŒí•˜ë©° ì¹´í…Œê³ ë¦¬ë³„ ê¸ˆì•¡ ì§‘ê³„
        category_spending = {}
        
        # ìƒí’ˆëª… ìš”ì•½ìš©
        item_names = []

        for item in cart_session.items:
            # item.product.category.name (ì˜ˆ: "ì •ìœ¡", "ìœ ì œí’ˆ" ë“± DBì— ì €ì¥ëœ ë¬¸ìì—´)
            # ê´€ê³„ ë¡œë”©ì´ ì•ˆ ë˜ì–´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì ‘ê·¼ ì‹œ ì¿¼ë¦¬ ë°œìƒ ê°€ëŠ¥
            prod_cat_name = "ETC"
            if item.product and item.product.category:
                prod_cat_name = item.product.category.name
            
            # ê¸ˆì•¡ ê³„ì‚°
            amount = item.quantity * item.unit_price
            
            # ì§‘ê³„
            category_spending[prod_cat_name] = category_spending.get(prod_cat_name, 0) + amount
            
            if item.product:
                item_names.append(item.product.name)

        # 3. ê°€ì¥ ë§ì´ ì“´ ì¹´í…Œê³ ë¦¬ ì°¾ê¸°
        if category_spending:
            top_category_name = max(category_spending, key=category_spending.get)
        else:
            top_category_name = "GROCERY"

        # 4. ë¬¸ìì—´ -> LedgerCategory Enum ë§¤í•‘
        # DBì˜ product_category.name ê³¼ LedgerCategory Enum ê°„ì˜ ë§¤í•‘ í…Œì´ë¸”
        # (í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ë¡œ ë§¤í•‘)
        CATEGORY_MAP = {
            "ì •ìœ¡": models.LedgerCategory.MEAT,
            "ê³ ê¸°": models.LedgerCategory.MEAT,
            "ì¶•ì‚°": models.LedgerCategory.MEAT,
            "ìœ ì œí’ˆ": models.LedgerCategory.DAIRY,
            "ìš°ìœ ": models.LedgerCategory.DAIRY,
            "ì¹˜ì¦ˆ": models.LedgerCategory.DAIRY,
            "ìŒë£Œ": models.LedgerCategory.BEVERAGE,
            "ê³¼ì": models.LedgerCategory.SNACK,
            "ê°„ì‹": models.LedgerCategory.SNACK,
            "ìŠ¤ë‚µ": models.LedgerCategory.SNACK,
            "ìƒí™œ": models.LedgerCategory.HOUSEHOLD,
            "ì±„ì†Œ": models.LedgerCategory.GROCERY,
            "ì•¼ì±„": models.LedgerCategory.GROCERY,
            "ê³¼ì¼": models.LedgerCategory.GROCERY,
            "ìˆ˜ì‚°": models.LedgerCategory.GROCERY,
            "í•´ì‚°ë¬¼": models.LedgerCategory.GROCERY,
            "í†µì¡°ë¦¼": models.LedgerCategory.GROCERY, # ê°€ê³µì‹í’ˆì€ ë³´í†µ GROCERY
            "ì†ŒìŠ¤": models.LedgerCategory.GROCERY,
            "ì–‘ë…": models.LedgerCategory.GROCERY,
            "ë©´": models.LedgerCategory.GROCERY,
            "ì¦‰ì„": models.LedgerCategory.GROCERY,
        }
        
        main_category = models.LedgerCategory.GROCERY # ê¸°ë³¸ê°’
        
        # í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ í™•ì¸ (ì˜ˆ: "ì •ìœ¡/ê³„ë€" -> "ì •ìœ¡" í¬í•¨ -> MEAT)
        for key, val in CATEGORY_MAP.items():
            if key in top_category_name:
                main_category = val
                break
        
        # ë©”ëª¨ ìƒì„± (ì˜ˆ: "ì‚¼ê²¹ì‚´ ì™¸ 3ê±´")
        if len(item_names) == 1:
            memo_text = item_names[0]
        elif len(item_names) > 1:
            memo_text = f"{item_names[0]} ì™¸ {len(item_names) - 1}ê±´"
        else:
            memo_text = "ìƒí’ˆ ì •ë³´ ì—†ìŒ"

    # --- ì¹´í…Œê³ ë¦¬ ìë™ ë§¤í•‘ ë¡œì§ ë ---

    # ledger ìƒì„±
    ledger = models.LedgerEntry(
        user_id=payment.user_id,
        payment_id=payment.payment_id,
        spend_date=date.today(),
        category=main_category,  
        amount=payment.total_amount,
        memo=memo_text,
    )

    db.add(ledger)
    db.commit()
    db.refresh(ledger)

    return ledger


# ======================================================
# 2ï¸âƒ£ ê°€ê³„ë¶€ ëª©ë¡ ì¡°íšŒ
# ======================================================
@router.get("")
def get_ledger_list(
    user_id: int = Query(..., description="ì‚¬ìš©ì ID"),
    start_date: Optional[date] = Query(None, description="ì¡°íšŒ ì‹œì‘ì¼"),
    end_date: Optional[date] = Query(None, description="ì¡°íšŒ ì¢…ë£Œì¼"),
    category: Optional[models.LedgerCategory] = Query(None, description="ì¹´í…Œê³ ë¦¬"),
    db: Session = Depends(get_db),
):
    query = db.query(models.LedgerEntry).filter(
        models.LedgerEntry.user_id == user_id
    )

    # ë‚ ì§œ í•„í„°
    if start_date:
        query = query.filter(models.LedgerEntry.spend_date >= start_date)

    if end_date:
        query = query.filter(models.LedgerEntry.spend_date <= end_date)

    # ì¹´í…Œê³ ë¦¬ í•„í„°
    if category:
        query = query.filter(models.LedgerEntry.category == category)

    ledgers = (
        query
        .order_by(models.LedgerEntry.spend_date.desc())
        .all()
    )

    return [
        {
            "ledger_entry_id": l.ledger_entry_id,
            "payment_id": l.payment_id,
            "spend_date": l.spend_date,
            "category": l.category,
            "amount": l.amount,
            "memo": l.memo,
        }
        for l in ledgers
    ]

# ======================================================
# 6ï¸âƒ£ ì›”ë³„ ê°€ê³„ë¶€ ìº˜ë¦°ë” ì¡°íšŒ (ë‚ ì§œë³„ ì§€ì¶œ í•©ê³„)
# ======================================================
@router.get("/calendar")
def get_ledger_calendar(
    year: int = Query(..., ge=2000, description="ì¡°íšŒ ì—°ë„"),
    month: int = Query(..., ge=1, le=12, description="ì¡°íšŒ ì›” (1~12)"),
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    # ì›” ì‹œì‘ / ì¢…ë£Œì¼ ê³„ì‚°
    start_date = date(year, month, 1)
    last_day = monthrange(year, month)[1]
    end_date = date(year, month, last_day)

    rows = (
        db.query(
            models.LedgerEntry.spend_date,
            func.sum(models.LedgerEntry.amount).label("total_amount"),
        )
        .filter(
            models.LedgerEntry.user_id == current_user.user_id,
            models.LedgerEntry.spend_date >= start_date,
            models.LedgerEntry.spend_date <= end_date,
        )
        .group_by(models.LedgerEntry.spend_date)
        .order_by(models.LedgerEntry.spend_date)
        .all()
    )

    daily_total = {}
    for spend_date, total_amount in rows:
        daily_total[str(spend_date)] = int(total_amount)

    return {
        "year": year,
        "month": month,
        "daily_total": daily_total,
    }

# ======================================================
# 5ï¸âƒ£ ì›”ë³„ ê°€ê³„ë¶€ ìš”ì•½ ì¡°íšŒ
# ======================================================
@router.get("/summary/monthly")
def get_monthly_summary(
    year: int = Query(..., ge=2000, description="ì¡°íšŒ ì—°ë„"),
    month: int = Query(..., ge=1, le=12, description="ì¡°íšŒ ì›” (1~12)"),
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    # ì›” ì‹œì‘ / ì¢…ë£Œì¼ ê³„ì‚°
    start_date = date(year, month, 1)
    last_day = monthrange(year, month)[1]
    end_date = date(year, month, last_day)

    # ì¹´í…Œê³ ë¦¬ë³„ í•©ê³„ ì¡°íšŒ
    rows = (
        db.query(
            models.LedgerEntry.category,
            func.sum(models.LedgerEntry.amount).label("amount"),
        )
        .filter(
            models.LedgerEntry.user_id == current_user.user_id,
            models.LedgerEntry.spend_date >= start_date,
            models.LedgerEntry.spend_date <= end_date,
        )
        .group_by(models.LedgerEntry.category)
        .all()
    )

    by_category = [
        {
            "category": category,
            "amount": amount,
        }
        for category, amount in rows
    ]

    total_amount = sum(item["amount"] for item in by_category)

    # ğŸ”¹ ratio(%) ê³„ì‚°
    for item in by_category:
        item["ratio"] = round(item["amount"] / total_amount * 100) if total_amount > 0 else 0

    by_category.sort(key=lambda x: x["amount"], reverse=True)
    return {
        "year": year,
        "month": month,
        "total_amount": total_amount,
        "by_category": by_category,
    }

# ======================================================
# 7ï¸âƒ£ Top Categories ì¡°íšŒ (ì§€ì¶œ ê¸ˆì•¡ ê¸°ì¤€)
# ======================================================
@router.get("/top-categories")
def get_top_categories(
    year: int = Query(..., ge=2000, description="ì¡°íšŒ ì—°ë„"),
    month: int = Query(..., ge=1, le=12, description="ì¡°íšŒ ì›” (1~12)"),
    limit: int = Query(5, ge=1, le=10, description="ìƒìœ„ ì¹´í…Œê³ ë¦¬ ê°œìˆ˜"),
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    # ì›” ì‹œì‘ / ì¢…ë£Œì¼ ê³„ì‚°
    start_date = date(year, month, 1)
    last_day = monthrange(year, month)[1]
    end_date = date(year, month, last_day)

    rows = (
        db.query(
            models.LedgerEntry.category,
            func.sum(models.LedgerEntry.amount).label("amount"),
        )
        .filter(
            models.LedgerEntry.user_id == current_user.user_id,
            models.LedgerEntry.spend_date >= start_date,
            models.LedgerEntry.spend_date <= end_date,
        )
        .group_by(models.LedgerEntry.category)
        .order_by(func.sum(models.LedgerEntry.amount).desc())
        .limit(limit)
        .all()
    )

    categories = [
        {
            "category": category,
            "amount": amount,
        }
        for category, amount in rows
    ]

    total_amount = sum(item["amount"] for item in categories)

    for item in categories:
        item["ratio"] = round(item["amount"] / total_amount * 100) if total_amount > 0 else 0

    return {
        "year": year,
        "month": month,
        "categories": categories,
    }

# ======================================================
# 8ï¸âƒ£ Top Items ì¡°íšŒ (êµ¬ë§¤ íšŸìˆ˜ ê¸°ì¤€ - ì„ì‹œ: ì¹´í…Œê³ ë¦¬ ì‚¬ìš©)
# ======================================================
@router.get("/top-items")
def get_top_items(
    year: int = Query(..., ge=2000, description="ì¡°íšŒ ì—°ë„"),
    month: int = Query(..., ge=1, le=12, description="ì¡°íšŒ ì›” (1~12)"),
    limit: int = Query(5, ge=1, le=10, description="ìƒìœ„ ì•„ì´í…œ ê°œìˆ˜"),
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    start_date = date(year, month, 1)
    last_day = monthrange(year, month)[1]
    end_date = date(year, month, last_day)

    rows = (
        db.query(
            models.LedgerEntry.category.label("item_name"),
            func.count(models.LedgerEntry.ledger_entry_id).label("count"),
            func.sum(models.LedgerEntry.amount).label("total_amount"),
        )
        .filter(
            models.LedgerEntry.user_id == current_user.user_id,
            models.LedgerEntry.spend_date >= start_date,
            models.LedgerEntry.spend_date <= end_date,
        )
        .group_by(models.LedgerEntry.category)
        .order_by(
            func.count(models.LedgerEntry.ledger_entry_id).desc(),
            func.sum(models.LedgerEntry.amount).desc(),
        )
        .limit(limit)
        .all()
    )

    items = [
        {
            "item_name": item_name,
            "count": count,
            "total_amount": total_amount,
        }
        for item_name, count, total_amount in rows
    ]

    return {
        "year": year,
        "month": month,
        "items": items,
    }

# ======================================================
# 9ï¸âƒ£ ìµœê·¼ ì§€ì¶œ ë‚´ì—­ ì¡°íšŒ
# ======================================================
@router.get("/recent")
def get_recent_ledger(
    limit: int = Query(5, ge=1, le=20),
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    rows = (
        db.query(models.LedgerEntry, models.Payment)
        .join(
            models.Payment,
            models.LedgerEntry.payment_id == models.Payment.payment_id,
        )
        .filter(
            models.LedgerEntry.user_id == current_user.user_id,
            models.Payment.status == models.PaymentStatus.APPROVED,
        )
        .order_by(models.LedgerEntry.ledger_entry_id.desc())
        .limit(limit)
        .all()
    )

    items = []
    for ledger, payment in rows:
        items.append({
            "ledger_entry_id": ledger.ledger_entry_id,
            "payment_id": payment.payment_id,
            "spend_date": ledger.spend_date,
            "amount": ledger.amount,
            "category": ledger.category,
            "memo": ledger.memo,
        })

    return {"items": items}


# ======================================================
# 3ï¸âƒ£ ê°€ê³„ë¶€ ë‹¨ê±´ ì¡°íšŒ (JWT ì¸ì¦ + ë³¸ì¸ ë°ì´í„°ë§Œ)
# ======================================================
@router.get("/{ledger_entry_id}")
def get_ledger_detail(
    ledger_entry_id: int,
    db: Session = Depends(get_db),
    # í”„ë¡œì íŠ¸ì— ì´ë¯¸ ì“°ê³  ìˆëŠ” ì¸ì¦ ì˜ì¡´ì„± ì‚¬ìš©
    current_user: models.AppUser = Depends(get_current_user),
):
    ledger = db.query(models.LedgerEntry).filter(
        models.LedgerEntry.ledger_entry_id == ledger_entry_id
    ).first()

    if not ledger:
        raise HTTPException(status_code=404, detail="ê°€ê³„ë¶€ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # ë³¸ì¸ ê°€ê³„ë¶€ë§Œ ì¡°íšŒ ê°€ëŠ¥
    if ledger.user_id != current_user.user_id:
        raise HTTPException(status_code=403, detail="ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")

    return {
        "ledger_entry_id": ledger.ledger_entry_id,
        "payment_id": ledger.payment_id,
        "spend_date": ledger.spend_date,
        "category": ledger.category,
        "amount": ledger.amount,
        "memo": ledger.memo,
    }

# ======================================================
# 4ï¸âƒ£ ê°€ê³„ë¶€ ìˆ˜ì • (ì¹´í…Œê³ ë¦¬ / ë©”ëª¨ë§Œ)
# ======================================================
@router.put("/{ledger_entry_id}")
def update_ledger(
    ledger_entry_id: int,
    data: LedgerUpdateRequest,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user),
):
    ledger = (
        db.query(models.LedgerEntry)
        .filter(models.LedgerEntry.ledger_entry_id == ledger_entry_id)
        .first()
    )

    if not ledger:
        raise HTTPException(status_code=404, detail="ê°€ê³„ë¶€ ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # ğŸ” ë³¸ì¸ ë°ì´í„°ë§Œ ìˆ˜ì • ê°€ëŠ¥
    if ledger.user_id != current_user.user_id:
        raise HTTPException(status_code=403, detail="ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.")

    if data.category is not None:
        ledger.category = data.category

    if data.memo is not None:
        ledger.memo = data.memo

    db.commit()
    db.refresh(ledger)

    return {
        "ledger_entry_id": ledger.ledger_entry_id,
        "payment_id": ledger.payment_id,
        "spend_date": ledger.spend_date,
        "category": ledger.category,
        "amount": ledger.amount,
        "memo": ledger.memo,
    }




----------------------------------------
End of file: app\routers\ledger.py


Start of file: app\routers\payment.py
----------------------------------------
import httpx
import os
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy.orm import Session

# ë‚´ë¶€ ëª¨ë“ˆ ì„í¬íŠ¸
from .. import models, schemas, database
from ..dependencies import get_current_user, get_db
from app.utils.check_data import validate_cart_weight
from .ledger import create_ledger_from_payment

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
BASE_URL = os.getenv("BASE_URL", "http://localhost:8000")
KAKAO_ADMIN_KEY = os.getenv("KAKAO_ADMIN_KEY")

# ë¼ìš°í„° ì„¤ì •
router = APIRouter(
    prefix="/api/payments",
    tags=["payments"],
    responses={404: {"description": "Resource Not found"}},
)


# --- ì¹´ì¹´ì˜¤í˜ì´ CID ì„¤ì • ---
# CIDëŠ” ê°€ë§¹ì  ì½”ë“œì…ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ìš© ì½”ë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
CID_ONETIME = "TC0ONETIME"       # ì¼ë°˜ ê²°ì œ (1íšŒì„±, QR/PC)
CID_SUBSCRIPTION = "TCSUBSCRIP"  # ì •ê¸°/ìë™ ê²°ì œ (ë¹Œë§í‚¤ ì‚¬ìš©)


# =========================================================
# ğŸ› ï¸ í—¬í¼ í•¨ìˆ˜ (ë‚´ë¶€ ì‚¬ìš©)
# =========================================================

def get_payment_or_404(payment_id: int, user_id: int, db: Session):
    """ê²°ì œ IDë¡œ ê²°ì œ ë‚´ì—­ì„ ì¡°íšŒí•˜ê³ , ì—†ìœ¼ë©´ 404 ì—ëŸ¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    payment = db.query(models.Payment).filter(
        models.Payment.payment_id == payment_id,
        models.Payment.user_id == user_id
    ).first()
    
    if not payment:
        raise HTTPException(status_code=404, detail="ê²°ì œ ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    return payment


# =========================================================
# ğŸ›ï¸ [Main] ê²°ì œ ìš”ì²­ ë° ê²€ì¦ (ì›¹ í”„ë¡ íŠ¸ì—”ë“œ ì—°ë™)
# =========================================================

@router.post("/request")
async def request_payment(
    req: schemas.PaymentRequest,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    **[ê²°ì œ ìš”ì²­ API] ì›¹ì—ì„œ 'ê²°ì œí•˜ê¸°' ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œ í˜¸ì¶œë˜ëŠ” í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸ì…ë‹ˆë‹¤.**
    
    1. **ë¬´ê²Œ ì—…ë°ì´íŠ¸:** Jetson/ì„¼ì„œê°€ ì¸¡ì •í•œ ë¬´ê²Œ(`measured_weight_g`)ë¥¼ DBì— ë°˜ì˜í•©ë‹ˆë‹¤.
    2. **ë¬´ê²Œ ê²€ì¦:** ì˜ˆìƒ ë¬´ê²Œì™€ ì¸¡ì • ë¬´ê²Œë¥¼ ë¹„êµí•©ë‹ˆë‹¤.
    3. **ë¶„ê¸° ì²˜ë¦¬:**
       - ğŸš¨ **ë¶ˆì¼ì¹˜ ì‹œ:** 409 Conflict ìƒíƒœì½”ë“œì™€ í•¨ê»˜ ê²½ê³  ë©”ì‹œì§€, ë¬´ê²Œ ì°¨ì´ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. (í”„ë¡ íŠ¸ì—ì„œ íŒì—… ë„ì›€)
       - âœ… **ì¼ì¹˜ ì‹œ:** `use_subscription=True`ë¼ë©´ ì¦‰ì‹œ ìë™ ê²°ì œë¥¼ ì§„í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    
    # 1. í™œì„± ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ ì¡°íšŒ
    cart_session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == req.cart_session_id,
        models.CartSession.user_id == current_user.user_id,
        models.CartSession.status == models.CartSessionStatus.ACTIVE
    ).first()

    if not cart_session:
        raise HTTPException(status_code=404, detail="ê²°ì œí•  í™œì„± ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # 2. ì¸¡ì • ë¬´ê²Œ ì—…ë°ì´íŠ¸ (Jetson -> Web -> Server DB)
    # ê²°ì œ ì „ ê°€ì¥ ìµœì‹  ë¬´ê²Œ ìƒíƒœë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
    cart_session.measured_total_g = req.measured_weight_g
    db.commit() 

    # 3. ë¬´ê²Œ ê²€ì¦ ë¡œì§ ìˆ˜í–‰
    weight_check = validate_cart_weight(
        db=db,
        cart_session_id=req.cart_session_id,
        measured_weight_g=req.measured_weight_g
    )

    # 4. [ê²€ì¦ ì‹¤íŒ¨] ë¬´ê²Œ ë¶ˆì¼ì¹˜ -> ê²½ê³  ì‘ë‹µ (409 Conflict)
    if not weight_check["is_valid"]:
        # í”„ë¡ íŠ¸ì—”ë“œëŠ” ì´ ì‘ë‹µì„ ë°›ìœ¼ë©´ ê²°ì œë¥¼ ì¤‘ë‹¨í•˜ê³  'ìƒí’ˆ ì ê²€ íŒì—…'ì„ ë„ì›Œì•¼ í•©ë‹ˆë‹¤.
        return JSONResponse(
            status_code=409, 
            content={
                "status": "WARNING",
                "message": weight_check["message"], # ì˜ˆ: "ë¬´ê²Œê°€ 200g ë” ë¬´ê²ìŠµë‹ˆë‹¤."
                "difference": weight_check["difference"],
                "expected_weight": weight_check["expected_weight"],
                "measured_weight": weight_check["measured_weight"],
                "action_required": "CHECK_CART_ITEMS" 
            }
        )

    # 5. [ê²€ì¦ ì„±ê³µ] ë¬´ê²Œ ì¼ì¹˜ -> ê²°ì œ ì§„í–‰
    # ì‚¬ìš©ìê°€ ìë™ê²°ì œ(êµ¬ë…) ë°©ì‹ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°
    if req.use_subscription:
        # --- ë‚´ë¶€ ìë™ ê²°ì œ ë¡œì§ ì‹œì‘ ---
        try:
            # 5-1. ë“±ë¡ëœ ë¹Œë§í‚¤(ì¹´ë“œ) ì¡°íšŒ
            my_card = db.query(models.PaymentMethod).filter(
                models.PaymentMethod.user_id == current_user.user_id,
                models.PaymentMethod.billing_key.isnot(None)
            ).order_by(models.PaymentMethod.is_default.desc()).first()
            
            if not my_card:
                raise HTTPException(status_code=404, detail="ë“±ë¡ëœ ìë™ê²°ì œ ìˆ˜ë‹¨ì´ ì—†ìŠµë‹ˆë‹¤. ë§ˆì´í˜ì´ì§€ì—ì„œ ì¹´ë“œë¥¼ ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”.")

            # 5-2. ì¹´ì¹´ì˜¤í˜ì´ ì •ê¸°ê²°ì œ API í˜¸ì¶œ
            url = "https://kapi.kakao.com/v1/payment/subscription"
            headers = {
                "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
                "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
            }
            
            # ì£¼ë¬¸ë²ˆí˜¸ì— ì„¸ì…˜IDì™€ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì¡°í•©í•´ ìœ ë‹ˆí¬í•˜ê²Œ ìƒì„±
            partner_order_id = f"sub_{req.cart_session_id}_{int(datetime.now().timestamp())}"

            pay_data = {
                "cid": CID_SUBSCRIPTION,
                "sid": my_card.billing_key, # ì €ì¥ëœ ë¹Œë§í‚¤ ì‚¬ìš©
                "partner_order_id": partner_order_id,
                "partner_user_id": str(current_user.user_id),
                "item_name": "ìŠ¤ë§ˆíŠ¸ ì¥ë°”êµ¬ë‹ˆ ê²°ì œ",
                "quantity": 1,
                "total_amount": req.amount,
                "tax_free_amount": 0,
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(url, headers=headers, data=pay_data)
                res_data = response.json()
                
            if "tid" not in res_data:
                # ì¹´ì¹´ì˜¤í˜ì´ ì¸¡ ì—ëŸ¬ (ì”ì•¡ ë¶€ì¡±, í•œë„ ì´ˆê³¼ ë“±)
                raise HTTPException(status_code=400, detail=f"ê²°ì œ ìŠ¹ì¸ ì‹¤íŒ¨: {res_data}")

            # 5-3. ê²°ì œ ì„±ê³µ ì²˜ë¦¬
            # (1) Payment ë‚´ì—­ ì €ì¥
            new_payment = models.Payment(
                user_id=current_user.user_id,
                cart_session_id=req.cart_session_id,
                method_id=my_card.method_id,
                pg_provider=models.PgProviderType.KAKAO_PAY,
                pg_tid=res_data['tid'],
                status=models.PaymentStatus.APPROVED,
                total_amount=req.amount,
                approved_at=datetime.now()
            )
            db.add(new_payment)
            
            # (2) ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ ì¢…ë£Œ (ACTIVE -> PAID)
            cart_session.status = models.CartSessionStatus.PAID
            cart_session.ended_at = datetime.now()
            
            db.commit()
            db.refresh(new_payment)
            
            # (3) ê°€ê³„ë¶€ ìë™ ë“±ë¡ (ì‹¤íŒ¨í•´ë„ ê²°ì œëŠ” ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬)
            try:
                create_ledger_from_payment(payment_id=new_payment.payment_id, db=db)
            except Exception as e:
                print(f"âš ï¸ ê°€ê³„ë¶€ ìë™ë“±ë¡ ì‹¤íŒ¨: {e}")

            return {
                "status": "SUCCESS",
                "message": "ê²°ì œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
                "amount": req.amount,
                "tid": res_data["tid"],
                "approved_at": res_data["approved_at"]
            }

        except HTTPException as e:
            raise e
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"ê²°ì œ ì²˜ë¦¬ ì¤‘ ì„œë²„ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")

    else:
        # ìë™ê²°ì œë¥¼ ì›ì¹˜ ì•ŠëŠ” ê²½ìš° (ì˜ˆ: í˜„ì¥ QR ê²°ì œ ë“±)
        return {"message": "ì¼ë°˜ ê²°ì œ(QR) ë¡œì§ì€ /ready APIë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”."}


# =========================================================
# ğŸ†• [ì„¤ì •] ì •ê¸°ê²°ì œ(Billing Key) ë“±ë¡ í”„ë¡œì„¸ìŠ¤
# =========================================================

# --- 1. ì¹´ë“œ ë“±ë¡ ì¤€ë¹„ (ì¸ì¦ ìš”ì²­) ---
@router.post("/subscription/register/ready", response_model=schemas.PaymentReadyResponse)
async def register_card_ready(
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    **[ì¹´ë“œ ë“±ë¡ 1ë‹¨ê³„]** ì¹´ì¹´ì˜¤í˜ì´ì— 'ì¹´ë“œ ë“±ë¡(0ì› ê²°ì œ)'ì„ ìš”ì²­í•˜ì—¬ ì¸ì¦ URLì„ ë°›ì•„ì˜µë‹ˆë‹¤.
    - ë°˜í™˜ëœ `partner_order_id`ëŠ” 2ë‹¨ê³„(approve)ì—ì„œ ë°˜ë“œì‹œ ë™ì¼í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
    """
    url = "https://kapi.kakao.com/v1/payment/ready"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    
    # ì£¼ë¬¸ë²ˆí˜¸ ìƒì„± (ì´ ê°’ì„ ê¸°ì–µí•´ì•¼ í•¨!)
    order_id = f"reg_{current_user.user_id}_{int(datetime.now().timestamp())}"
    
    data = {
        "cid": CID_SUBSCRIPTION,  # ì •ê¸°ê²°ì œìš© CID
        "partner_order_id": order_id,
        "partner_user_id": str(current_user.user_id),
        "item_name": "ì¹´ë“œ ìë™ê²°ì œ ë“±ë¡",
        "quantity": 1,
        "total_amount": 0,    # ì¸ì¦ìš©ì´ë¼ 0ì›
        "tax_free_amount": 0,
        "approval_url": f"{BASE_URL}/api/payments/subscription/register/callback?status=success",
        "cancel_url": f"{BASE_URL}/api/payments/subscription/register/callback?status=cancel",
        "fail_url": f"{BASE_URL}/api/payments/subscription/register/callback?status=fail",
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()

    if "tid" not in res_data:
        raise HTTPException(status_code=400, detail=f"KakaoPay Error: {res_data}")

    return schemas.PaymentReadyResponse(
        tid=res_data['tid'],
        next_redirect_app_url=res_data.get('next_redirect_app_url'),
        next_redirect_mobile_url=res_data.get('next_redirect_mobile_url'),
        next_redirect_pc_url=res_data.get('next_redirect_pc_url'),
        partner_order_id=order_id # í´ë¼ì´ì–¸íŠ¸ê°€ ì´ ê°’ì„ ì €ì¥í•´ë’€ë‹¤ê°€ approve ë•Œ ë³´ë‚´ì¤˜ì•¼ í•¨
    )


# --- 2. ì¹´ë“œ ë“±ë¡ ìŠ¹ì¸ (Billing Key ë°œê¸‰) ---
@router.get("/subscription/register/approve")
async def register_card_approve(
    tid: str,
    pg_token: str,
    partner_order_id: str,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    **[ì¹´ë“œ ë“±ë¡ 2ë‹¨ê³„]** ì‚¬ìš©ìê°€ ì¹´í†¡ ì¸ì¦ì„ ë§ˆì¹˜ë©´ ë°›ì€ pg_tokenìœ¼ë¡œ ë¹Œë§í‚¤(SID)ë¥¼ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
    - ë°œê¸‰ë°›ì€ `billing_key`ëŠ” DB(`payment_method`)ì— ì•”í˜¸í™” ì €ì¥ë˜ì–´ ì¶”í›„ ê²°ì œì— ì‚¬ìš©ë©ë‹ˆë‹¤.
    """
    url = "https://kapi.kakao.com/v1/payment/approve"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    
    data = {
        "cid": CID_SUBSCRIPTION,
        "tid": tid,
        "partner_order_id": partner_order_id, # 1ë‹¨ê³„ì˜ ê·¸ IDì—¬ì•¼ í•¨
        "partner_user_id": str(current_user.user_id),
        "pg_token": pg_token
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()

    if "sid" not in res_data:
        raise HTTPException(status_code=400, detail=f"ë“±ë¡ ì‹¤íŒ¨ (ì£¼ë¬¸ë²ˆí˜¸ ë¶ˆì¼ì¹˜ ë“±): {res_data}")

    # SID(Billing Key) ì €ì¥
    sid = res_data["sid"]
    card_info = res_data.get("card_info", {})
    
    # ê¸°ì¡´ ë“±ë¡ëœ ê°™ì€ ì¹´ë“œê°€ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸, ì—†ìœ¼ë©´ ìƒì„±
    new_method = models.PaymentMethod(
        user_id=current_user.user_id,
        method_type=models.PaymentMethodType.KAKAO_PAY,
        billing_key=sid,  # â˜… í•µì‹¬: ì´ í‚¤ê°€ ìˆì–´ì•¼ ëˆì„ ëº„ ìˆ˜ ìˆìŒ
        card_brand=card_info.get("kakaopay_purchase_corp", "KAKAO"),
        card_last4=card_info.get("bin", "0000")[:4], 
        is_default=True 
    )
    
    db.add(new_method)
    db.commit()
    db.refresh(new_method)

    return {"message": "ì¹´ë“œ ë“±ë¡ ì™„ë£Œ", "billing_key": sid, "method_id": new_method.method_id}


# --- 3. ë‹¨ìˆœ ìë™ ê²°ì œ (í…ŒìŠ¤íŠ¸ìš©) ---
@router.post("/subscription/pay")
async def pay_subscription(
    cart_session_id: int,
    amount: int,
    item_name: str = "ìŠ¤ë§ˆíŠ¸ ì¥ë°”êµ¬ë‹ˆ ìë™ê²°ì œ",
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    **[í…ŒìŠ¤íŠ¸ìš©/ì§ì ‘í˜¸ì¶œìš©]** ë¬´ê²Œ ê²€ì¦ ë¡œì§ ì—†ì´ ì¦‰ì‹œ ê²°ì œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    - ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” `/request` ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
    """
    # 0. ì„¸ì…˜ í™•ì¸
    cart_session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == cart_session_id,
        models.CartSession.user_id == current_user.user_id,
        models.CartSession.status == models.CartSessionStatus.ACTIVE
    ).first()

    if not cart_session:
        raise HTTPException(status_code=404, detail="ê²°ì œí•  í™œì„± ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")

    # 1. ë¹Œë§í‚¤ ì¡°íšŒ
    my_card = db.query(models.PaymentMethod).filter(
        models.PaymentMethod.user_id == current_user.user_id,
        models.PaymentMethod.billing_key.isnot(None)
    ).order_by(models.PaymentMethod.is_default.desc()).first()
    
    if not my_card:
        raise HTTPException(status_code=404, detail="ë“±ë¡ëœ ìë™ê²°ì œ ìˆ˜ë‹¨ì´ ì—†ìŠµë‹ˆë‹¤.")

    # 2. ì¹´ì¹´ì˜¤í˜ì´ ìš”ì²­
    url = "https://kapi.kakao.com/v1/payment/subscription"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    
    data = {
        "cid": CID_SUBSCRIPTION,
        "sid": my_card.billing_key,
        "partner_order_id": f"sub_{cart_session_id}_{int(datetime.now().timestamp())}",
        "partner_user_id": str(current_user.user_id),
        "item_name": item_name,
        "quantity": 1,
        "total_amount": amount,
        "tax_free_amount": 0,
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()
        
    if "tid" not in res_data:
         raise HTTPException(status_code=400, detail=f"ìë™ ê²°ì œ ì‹¤íŒ¨: {res_data}")

    # 3. DB ì €ì¥ ë° ìƒíƒœ ì—…ë°ì´íŠ¸
    new_payment = models.Payment(
        user_id=current_user.user_id,
        cart_session_id=cart_session_id,
        method_id=my_card.method_id,
        pg_provider=models.PgProviderType.KAKAO_PAY,
        pg_tid=res_data['tid'],
        status=models.PaymentStatus.APPROVED,
        total_amount=amount,
        approved_at=datetime.now()
    )
    db.add(new_payment)
    
    cart_session.status = models.CartSessionStatus.PAID
    cart_session.ended_at = datetime.now()
    
    db.commit()
    db.refresh(new_payment)
    
    try:
        create_ledger_from_payment(payment_id=new_payment.payment_id, db=db)
    except Exception as e:
        print(f"ê°€ê³„ë¶€ ë“±ë¡ ì˜¤ë¥˜: {e}")

    return {
        "status": "SUCCESS",
        "amount": amount,
        "tid": res_data["tid"],
        "approved_at": res_data["approved_at"]
    }

# --- ì¹´ë“œ ë“±ë¡ìš© ì½œë°± (HTML) ---
@router.get("/subscription/register/callback", response_class=HTMLResponse)
async def register_callback(status: str, pg_token: str = None):
    """ì¹´ì¹´ì˜¤í†¡ ì¸ì¦ í›„ ë¦¬ë‹¤ì´ë ‰íŠ¸ë˜ëŠ” í˜ì´ì§€ì…ë‹ˆë‹¤. í† í°ì„ ë³´ì—¬ì¤ë‹ˆë‹¤."""
    if status == "success":
        return f"""
        <html>
            <head><title>ë“±ë¡ ì„±ê³µ</title></head>
            <body>
                <h1 style="color:blue;">ì¹´ë“œ ë“±ë¡ ì¸ì¦ ì™„ë£Œ!</h1>
                <p>ì•„ë˜ í† í°ì„ ë³µì‚¬í•´ì„œ <b>approve API</b>ì— ì…ë ¥í•˜ì„¸ìš”.</p>
                <div style="background:#eee; padding:10px; font-size:1.2em;">{pg_token}</div>
            </body>
        </html>
        """
    return "<h1>ë“±ë¡ ì·¨ì†Œ ë˜ëŠ” ì‹¤íŒ¨</h1>"


# =========================================================
# ğŸš€ [Legacy] ì¼ë°˜ 1íšŒì„± ê²°ì œ (QR/PC)
# =========================================================

@router.post("/ready", response_model=schemas.PaymentReadyResponse)
async def payment_ready(
    request: schemas.PaymentReadyRequest,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    [ì¼ë°˜ ê²°ì œ] 1íšŒì„± ê²°ì œ ìš”ì²­ì…ë‹ˆë‹¤. (ì¹´ì¹´ì˜¤í†¡ QRì½”ë“œ ìŠ¤ìº” ë°©ì‹)
    """
    user_id = current_user.user_id

    cart_session = db.query(models.CartSession).filter(
        models.CartSession.cart_session_id == request.cart_session_id
    ).first()
    
    if not cart_session:
        raise HTTPException(status_code=404, detail="í•´ë‹¹ ì¹´íŠ¸ ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # ë¬´ê²Œ ê²€ì¦ (ì¼ë°˜ ê²°ì œë„ ê²€ì¦ í•„ìˆ˜)
    weight_check = validate_cart_weight(
        db=db,
        cart_session_id=cart_session.cart_session_id,
        measured_weight_g=cart_session.measured_total_g
    )

    if not weight_check["is_valid"]:
        raise HTTPException(status_code=400, detail=weight_check["message"])

    # ê¸°ì¡´ ë¯¸ì™„ë£Œ ê²°ì œ ë‚´ì—­ ì •ë¦¬
    existing_payment = db.query(models.Payment).filter(
        models.Payment.cart_session_id == request.cart_session_id
    ).first()
    if existing_payment:
        db.delete(existing_payment)
        db.commit()

    url = "https://kapi.kakao.com/v1/payment/ready"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    
    data = {
        "cid": CID_ONETIME,  # â˜… 1íšŒì„± CID
        "partner_order_id": str(cart_session.cart_session_id),
        "partner_user_id": str(user_id),
        "item_name": "ìŠ¤ë§ˆíŠ¸ ì¥ë³´ê¸° ê²°ì œ",
        "quantity": 1,
        "total_amount": request.total_amount,
        "tax_free_amount": 0,
        "approval_url": f"{BASE_URL}/api/payments/success",
        "cancel_url": f"{BASE_URL}/api/payments/cancel",
        "fail_url": f"{BASE_URL}/api/payments/fail",
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()

    if "tid" not in res_data:
        raise HTTPException(status_code=400, detail=f"KakaoPay Error: {res_data}")

    new_payment = models.Payment(
        cart_session_id=cart_session.cart_session_id,
        user_id=user_id,
        pg_provider=models.PgProviderType.KAKAO_PAY,
        pg_tid=res_data['tid'],
        status=models.PaymentStatus.PENDING,
        total_amount=request.total_amount,
        method_id=request.method_id
    )
    db.add(new_payment)
    db.commit()

    return schemas.PaymentReadyResponse(
        tid=res_data['tid'],
        next_redirect_app_url=res_data.get('next_redirect_app_url'),
        next_redirect_mobile_url=res_data.get('next_redirect_mobile_url'),
        next_redirect_pc_url=res_data.get('next_redirect_pc_url')
    )


@router.post("/approve", response_model=schemas.PaymentResponse)
async def payment_approve(
    request: schemas.PaymentApproveRequest,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    [ì¼ë°˜ ê²°ì œ] ì‚¬ìš©ìê°€ QR ìŠ¹ì¸ í›„, TIDì™€ pg_tokenìœ¼ë¡œ ìµœì¢… ìŠ¹ì¸ ìš”ì²­
    """
    user_id = current_user.user_id

    payment = db.query(models.Payment).filter(
        models.Payment.pg_tid == request.tid,
        models.Payment.user_id == user_id,
        models.Payment.status == models.PaymentStatus.PENDING
    ).first()

    if not payment:
        raise HTTPException(status_code=404, detail="ëŒ€ê¸° ì¤‘ì¸ ê²°ì œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    url = "https://kapi.kakao.com/v1/payment/approve"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    data = {
        "cid": CID_ONETIME,
        "tid": request.tid,
        "partner_order_id": str(payment.cart_session_id),
        "partner_user_id": str(user_id),
        "pg_token": request.pg_token
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()

    if "aid" not in res_data:
        payment.status = models.PaymentStatus.FAILED
        db.commit()
        raise HTTPException(status_code=400, detail=f"Approval failed: {res_data}")

    payment.status = models.PaymentStatus.APPROVED
    payment.approved_at = datetime.now()
    
    # ì¥ë°”êµ¬ë‹ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
    if payment.cart_session_id:
        cart_session = db.query(models.CartSession).filter(
            models.CartSession.cart_session_id == payment.cart_session_id
        ).first()
        if cart_session:
            cart_session.status = models.CartSessionStatus.PAID
            cart_session.ended_at = datetime.now()

    db.commit()
    db.refresh(payment)

    # ê°€ê³„ë¶€ ì—°ë™
    try:
        create_ledger_from_payment(payment_id=payment.payment_id, db=db)
    except Exception as e:
        print(f"âš ï¸ ê°€ê³„ë¶€ ë“±ë¡ ì‹¤íŒ¨: {e}")

    return payment

# --- ì½œë°± URLë“¤ ---
@router.get("/success", response_class=HTMLResponse)
async def payment_success_callback(pg_token: str):
    return HTMLResponse(content=f"""
    <html>
        <head><title>ê²°ì œ ì„±ê³µ</title></head>
        <body style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh;">
            <h1 style="color:green;">âœ… ê²°ì œ ìŠ¹ì¸ ëŒ€ê¸°ì¤‘</h1>
            <p>ì•±ìœ¼ë¡œ ëŒì•„ê°€ì„œ ê²°ì œ ì™„ë£Œ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
            <p>í† í°: <b>{pg_token}</b></p>
        </body>
    </html>
    """)

@router.get("/cancel")
async def payment_cancel_callback():
    return JSONResponse(content={"message": "ê²°ì œ ì·¨ì†Œ", "status": "CANCELLED"})

@router.get("/fail")
async def payment_fail_callback():
    return JSONResponse(content={"message": "ê²°ì œ ì‹¤íŒ¨", "status": "FAILED"}, status_code=400)


# ========================================================
# ğŸ“¦ CRUD ë° ê´€ë¦¬ ê¸°ëŠ¥ (ê²°ì œ ìˆ˜ë‹¨, ì¡°íšŒ, ì·¨ì†Œ)
# ========================================================

@router.get("/methods", response_model=list[schemas.PaymentMethodResponse])
async def get_payment_methods(
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """ë“±ë¡ëœ ê²°ì œ ìˆ˜ë‹¨ ëª©ë¡ ì¡°íšŒ"""
    return db.query(models.PaymentMethod).filter(
        models.PaymentMethod.user_id == current_user.user_id
    ).all()


@router.post("/methods", response_model=schemas.PaymentMethodResponse)
async def register_payment_method(
    request: schemas.PaymentMethodCreate,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """[í…ŒìŠ¤íŠ¸ìš©] ê²°ì œ ìˆ˜ë‹¨ ìˆ˜ë™ ë“±ë¡ (ë¹Œë§í‚¤ ì§ì ‘ ì…ë ¥)"""
    user_id = current_user.user_id
    existing_count = db.query(models.PaymentMethod).filter(
        models.PaymentMethod.user_id == user_id
    ).count()
    is_default = (existing_count == 0)

    new_method = models.PaymentMethod(
        user_id=user_id,
        method_type=request.method_type,
        card_brand=request.card_brand,
        card_last4=request.card_last4,
        billing_key=request.billing_key,
        is_default=is_default or request.is_default
    )
    db.add(new_method)
    db.commit()
    db.refresh(new_method)
    return new_method


@router.delete("/methods/{method_id}")
async def delete_payment_method(
    method_id: int,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """ê²°ì œ ìˆ˜ë‹¨ ì‚­ì œ"""
    method = db.query(models.PaymentMethod).filter(
        models.PaymentMethod.method_id == method_id,
        models.PaymentMethod.user_id == current_user.user_id
    ).first()

    if not method:
        raise HTTPException(status_code=404, detail="ê²°ì œ ìˆ˜ë‹¨ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    db.delete(method)
    db.commit()
    return {"message": "ê²°ì œ ìˆ˜ë‹¨ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."}


@router.get("/{payment_id}", response_model=schemas.PaymentDetailResponse)
async def get_payment_detail(
    payment_id: int,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """ê²°ì œ ìƒì„¸ ë‚´ì—­ ì¡°íšŒ"""
    return get_payment_or_404(payment_id, current_user.user_id, db)


@router.post("/{payment_id}/cancel", response_model=schemas.PaymentResponse)
async def cancel_payment(
    payment_id: int,
    request: schemas.PaymentCancelRequest,
    db: Session = Depends(get_db),
    current_user: models.AppUser = Depends(get_current_user)
):
    """
    ê²°ì œ ì·¨ì†Œ ìš”ì²­ (ì „ì•¡ ì·¨ì†Œ)
    - ì¹´ì¹´ì˜¤í˜ì´ APIë¥¼ í†µí•´ ì‹¤ì œ í™˜ë¶ˆ ì²˜ë¦¬ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.
    """
    payment = get_payment_or_404(payment_id, current_user.user_id, db)

    if payment.status != models.PaymentStatus.APPROVED:
        raise HTTPException(status_code=400, detail="ìŠ¹ì¸ ì™„ë£Œëœ ê²°ì œë§Œ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

    url = "https://kapi.kakao.com/v1/payment/cancel"
    headers = {
        "Authorization": f"KakaoAK {KAKAO_ADMIN_KEY}",
        "Content-type": "application/x-www-form-urlencoded;charset=utf-8"
    }
    
    # ê²°ì œ ë°©ì‹(ì •ê¸°/ì¼ë°˜)ì— ë”°ë¼ CIDê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
    cid_to_use = CID_ONETIME if payment.method_id is None else CID_SUBSCRIPTION
    
    data = {
        "cid": cid_to_use, 
        "tid": payment.pg_tid,
        "cancel_amount": payment.total_amount,
        "cancel_tax_free_amount": 0,
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=data)
        res_data = response.json()

    if "tid" not in res_data:
        raise HTTPException(status_code=400, detail=f"Cancel failed: {res_data}")

    payment.status = models.PaymentStatus.CANCELLED
    db.commit()
    db.refresh(payment)

    return payment
----------------------------------------
End of file: app\routers\payment.py


Start of file: app\routers\product.py
----------------------------------------
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func

from app.database import get_db
from app.models import Product, ProductCategory

router = APIRouter(
    prefix="/api/products",
    tags=["products"]
)

# ìƒí’ˆ ëª©ë¡ ì¡°íšŒ
@router.get("/")
def read_products(db: Session = Depends(get_db)):
    products = db.query(Product).all()
    return [
        {
            "product_id": p.product_id,
            "name": p.name,
            "price": p.price,
            "stock_quantity": p.stock_quantity,
            "image_url": p.image_url,
            "product_info": p.product_info,
        }
        for p in products
    ]

# ìƒí’ˆ ê²€ìƒ‰ (ì›¹ / pg_trgm ê¸°ë°˜) 
@router.get("/search")
def search_products(
    q: str = Query(..., min_length=1, description="ê²€ìƒ‰ì–´"),
    db: Session = Depends(get_db),
):
    products = (
        db.query(Product)
        .filter(func.similarity(Product.name, q) > 0.2)
        .order_by(func.similarity(Product.name, q).desc())
        .limit(20)
        .all()
    )

    return [
        {
            "product_id": p.product_id,
            "name": p.name,
            "price": p.price,
            "stock_quantity": p.stock_quantity,
            "in_stock": p.stock_quantity > 0,
            "image_url": p.image_url,
        }
        for p in products
    ]

# ìƒí’ˆ ìƒì„¸ ì¡°íšŒ
@router.get("/{product_id}")
def read_product_detail(
    product_id: int,
    db: Session = Depends(get_db)
):
    product = (
        db.query(Product)
        .filter(Product.product_id == product_id)
        .first()
    )

    if not product:
        raise HTTPException(
            status_code=404,
            detail="Product not found"
        )

    return {
        "product_id": product.product_id,
        "name": product.name,
        "price": product.price,
        "stock_quantity": product.stock_quantity,
        "image_url": product.image_url,
        "product_info": product.product_info,
    }

# ìƒí’ˆ ìœ„ì¹˜ ì•ˆë‚´
@router.get("/{product_id}/location")
def get_product_location(
    product_id: int,
    db: Session = Depends(get_db),
):
    product = (
        db.query(Product)
        .join(ProductCategory)
        .filter(Product.product_id == product_id)
        .first()
    )

    if not product:
        raise HTTPException(status_code=404, detail="Product not found")

    category = product.category  # relationship ê¸°ì¤€

    return {
        "product_id": product.product_id,
        "category": category.name,
        "zone_code": category.zone_code,
        "aisle": category.zone_code.split("-")[0],  # A / B / C
    }

----------------------------------------
End of file: app\routers\product.py


Start of file: app\routers\recommendation.py
----------------------------------------
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import desc, asc
from typing import List

from .. import models, schemas, database
from ..dependencies import get_current_user

router = APIRouter(
    prefix="/api/recommendations",
    tags=["recommendations"],
)

@router.get("/by-product/{product_id}", response_model=List[schemas.RecipeRecommendResponse])
def recommend_recipes_ai(
    product_id: int, 
    cart_session_id: int = None, # ë‚´ ì¥ë°”êµ¬ë‹ˆë‘ ë¹„êµí•˜ë ¤ë©´ í•„ìš”
    db: Session = Depends(database.get_db)
):
    """
    [AI ì¶”ì²œ ë¡œì§]
    1. ì„ íƒí•œ ìƒí’ˆ(product_id)ì˜ ì„ë² ë”© ë²¡í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    2. pgvectorë¥¼ ì‚¬ìš©í•´ í•´ë‹¹ ìƒí’ˆê³¼ 'ì˜ë¯¸ì ìœ¼ë¡œ ê°€ì¥ ê°€ê¹Œìš´' ë ˆì‹œí”¼ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
    3. (ì˜µì…˜) í˜„ì¬ ì¥ë°”êµ¬ë‹ˆì— ì—†ëŠ” ë¶€ì¡±í•œ ì¬ë£Œë¥¼ ê³„ì‚°í•´ì„œ ì•Œë ¤ì¤ë‹ˆë‹¤.
    """
    
    # 1. ìƒí’ˆ ì¡°íšŒ (ë²¡í„° í¬í•¨)
    target_product = db.query(models.Product).filter(models.Product.product_id == product_id).first()
    if not target_product:
        raise HTTPException(status_code=404, detail="ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # 2. AI ì¶”ì²œ ì¿¼ë¦¬ ì‘ì„±
    # embeddingì´ ìˆëŠ” ê²½ìš°: ì½”ì‚¬ì¸ ê±°ë¦¬(Cosine Distance)ë¡œ ìœ ì‚¬ë„ ì •ë ¬
    # embeddingì´ ì—†ëŠ” ê²½ìš°: ë‹¨ìˆœíˆ í•´ë‹¹ ì¬ë£Œë¥¼ í¬í•¨í•˜ëŠ” ë ˆì‹œí”¼ ê²€ìƒ‰ (Fallback)
    
    if target_product.embedding is not None:
        # ğŸ”¥ í•µì‹¬: pgvectorì˜ <=> ì—°ì‚°ì (Cosine Distance) ì‚¬ìš©
        # ìƒí’ˆì˜ ë²¡í„°ì™€ ë ˆì‹œí”¼ì˜ ë²¡í„° ê±°ë¦¬ê°€ ê°€ê¹Œìš¸ìˆ˜ë¡ ìƒìœ„ì— ë…¸ì¶œ
        recommendations = (
            db.query(models.Recipe)
            .order_by(models.Recipe.embedding.cosine_distance(target_product.embedding))
            .limit(5)
            .all()
        )
    else:
        # ë²¡í„°ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ì²˜ëŸ¼ 'ì¬ë£Œ í¬í•¨ ì—¬ë¶€'ë¡œ ê²€ìƒ‰ (Hard Rule)
        recommendations = (
            db.query(models.Recipe)
            .join(models.RecipeIngredient)
            .filter(models.RecipeIngredient.product_id == product_id)
            .limit(5)
            .all()
        )

    # 3. ì¥ë°”êµ¬ë‹ˆ ë¹„êµë¥¼ ìœ„í•œ ë‚´ ì•„ì´í…œ ì¡°íšŒ
    my_owned_product_ids = set()
    if cart_session_id:
        my_items = db.query(models.CartItem).filter(models.CartItem.cart_session_id == cart_session_id).all()
        my_owned_product_ids = {item.product_id for item in my_items}
        # ë°©ê¸ˆ ì°ì€ ìƒí’ˆë„ í¬í•¨
        my_owned_product_ids.add(product_id)

    # 4. ì‘ë‹µ ë°ì´í„° ì¡°ë¦½ (ë¶€ì¡±í•œ ì¬ë£Œ ê³„ì‚°)
    results = []
    for recipe in recommendations:
        # ì´ ë ˆì‹œí”¼ì˜ ëª¨ë“  ì¬ë£Œ ê°€ì ¸ì˜¤ê¸°
        recipe_ingredients = db.query(models.RecipeIngredient).filter(
            models.RecipeIngredient.recipe_id == recipe.recipe_id
        ).all()
        
        all_ingredients = []
        missing_list = []
        for ri in recipe_ingredients:
            # ì£¼ì¬ë£Œ(Product) ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            ing_product = ri.product 
            is_owned = ing_product.product_id in my_owned_product_ids
            
            # ì „ì²´ ì¬ë£Œ ë¦¬ìŠ¤íŠ¸
            all_ingredients.append({
                "product_id": ing_product.product_id,
                "name": ing_product.name,
                "is_owned": is_owned
            })
            
            if not is_owned:
                missing_list.append({
                    "product_id": ing_product.product_id,
                    "name": ing_product.name,
                    "is_owned": False
                })

        # ê²°ê³¼ ì¶”ê°€
        results.append({
            "recipe_id": recipe.recipe_id,
            "title": recipe.title,
            "description": recipe.description,
            "image_url": recipe.image_url,
            # AI ìœ ì‚¬ë„ ì ìˆ˜ê°€ ìˆìœ¼ë©´ ë„£ê³  ì•„ë‹ˆë©´ 0 (embeddingì´ ì—†ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ)
            "similarity_score": 0.0, # ê³„ì‚°í•˜ë ¤ë©´ ì¿¼ë¦¬ì—ì„œ distance ì»¬ëŸ¼ì„ select í•´ì•¼ í•¨ (ë³µì¡ë„ ë•Œë¬¸ì— ìƒëµí•˜ê±°ë‚˜ ì¶”í›„ ê³ ë„í™”)
            "ingredients": all_ingredients,  
            "missing_ingredients": missing_list
        })

    return results
----------------------------------------
End of file: app\routers\recommendation.py


Start of file: app\routers\user.py
----------------------------------------
# app/routers/user.py
from fastapi import APIRouter, Depends, HTTPException, status, Response
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from app.database import get_db
from app import schemas
from app.models import AppUser, UserProvider
from app.utils.security import hash_password, verify_password
from app.utils.jwt import create_access_token, create_refresh_token
from app.dependencies import get_current_user
from app.schemas import UserNicknameUpdate, UserPasswordUpdate
from datetime import datetime


router = APIRouter(prefix="/api", tags=["User"])


# íšŒì›ê°€ì…
@router.post("/auth/signup", response_model=schemas.UserMeResponse)
def signup(
    request: schemas.UserCreate,
    db: Session = Depends(get_db)
):
    try:
        user = AppUser(
            email=request.email,
            password_hash=hash_password(request.password),
            nickname=request.nickname,
            provider=UserProvider.LOCAL
        )
        db.add(user)
        db.commit()
        db.refresh(user)
        return user

    # ì´ë©”ì¼ ì¤‘ë³µ
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # í•´ì‹œ ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ì˜ˆì™¸ë¥¼ 422ë¡œ ë³€í™˜ (ì„œë²„ 500 ë°©ì§€)
    except ValueError as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=str(e)
        )

# ë¡œê·¸ì¸
@router.post("/auth/login")
def login(
    request: schemas.UserLogin,
    response: Response,             
    db: Session = Depends(get_db)
):
    user = (
        db.query(AppUser)
        .filter(AppUser.email == request.email)
        .first()
    )

    if not user or not user.password_hash:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    if not verify_password(request.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    access_token = create_access_token(str(user.user_id))
    refresh_token = create_refresh_token(str(user.user_id))

    # Refresh Tokenì„ HttpOnly Cookieë¡œ ì„¤ì •
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="lax",
        secure=False,   # HTTPSë©´ True
        path="/"
    )

    # dictë¡œ ë°˜í™˜ (FastAPIê°€ JSON Response ìë™ ìƒì„±)
    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

# ë¡œê·¸ì•„ì›ƒ
@router.post("/auth/logout")
def logout(response: Response):
    response.delete_cookie(
        key="refresh_token",
        path="/",
    )
    return {"message": "Logged out successfully"}


# ë‚´ ì •ë³´ ì¡°íšŒ
@router.get("/users/me", response_model=schemas.UserMeResponse)
def read_me(
    current_user: AppUser = Depends(get_current_user)
):
    return current_user

# ë‹‰ë„¤ì„ ë³€ê²½
@router.patch("/users/me/nickname", response_model=schemas.UserMeResponse)
def update_nickname(
    req: schemas.UserNicknameUpdate,
    db: Session = Depends(get_db),
    current_user: AppUser = Depends(get_current_user),
):
    current_user.nickname = req.nickname
    db.commit()
    db.refresh(current_user)
    return current_user


# ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
@router.patch("/users/me/password")
def update_password(
    req: schemas.UserPasswordUpdate,
    db: Session = Depends(get_db),
    current_user: AppUser = Depends(get_current_user),
):
    # OAuth ìœ ì € ì°¨ë‹¨
    if current_user.provider != UserProvider.LOCAL:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="OAuth users cannot change password"
        )

    # í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ 
    if not verify_password(req.current_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Current password is incorrect"
        )

    current_user.password_hash = hash_password(req.new_password)
    db.commit()

    return {"message": "Password updated successfully"}


# íšŒì›íƒˆí‡´
@router.delete("/users/me")
def withdraw_user(
    req: schemas.UserWithdraw,
    response: Response,
    db: Session = Depends(get_db),
    current_user: AppUser = Depends(get_current_user),
):
    # ì´ë¯¸ íƒˆí‡´í•œ ìœ ì € ë°©ì–´
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User already withdrawn"
        )

    # LOCAL ìœ ì € â†’ ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
    if current_user.provider == UserProvider.LOCAL:
        if not req.password:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password is required"
            )
        if not verify_password(req.password, current_user.password_hash):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password is incorrect"
            )

    # Soft delete ì²˜ë¦¬
    current_user.is_active = False
    current_user.deleted_at = datetime.utcnow()
    db.commit()

    # ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬ (refresh token ì œê±°)
    response.delete_cookie(
        key="refresh_token",
        path="/"
    )

    return {"message": "Account withdrawn successfully"}

----------------------------------------
End of file: app\routers\user.py


Start of file: app\routers\__init__.py
----------------------------------------

----------------------------------------
End of file: app\routers\__init__.py


Start of file: app\utils\check_data.py
----------------------------------------
from sqlalchemy.orm import Session
from fastapi import HTTPException
from app.models import CartSession, CartItem, Product

# ì˜¤ì°¨ í—ˆìš© 
TOLERANCE_RATE = 0.05  # 5%

# ë¬´ê²Œ ê²€ì¦
def validate_cart_weight(
    db: Session,
    cart_session_id: int,
    measured_weight_g: int
) -> dict:
    cart = db.query(CartSession).filter(
        CartSession.cart_session_id == cart_session_id
    ).first()

    items = db.query(CartItem).join(Product).filter(
        CartItem.cart_session_id == cart_session_id
    ).all()

    expected_weight = sum(
        item.quantity * item.product.unit_weight_g
        for item in items
    )

    difference = measured_weight_g - expected_weight
    tolerance = int(expected_weight * TOLERANCE_RATE)

    if abs(difference) <= tolerance:
        status = "MATCH"
        message = "ë¬´ê²Œ ê²€ì¦ í†µê³¼. ê²°ì œ ê°€ëŠ¥í•©ë‹ˆë‹¤."
    elif difference > 0:
        status = "OVER_WEIGHT"
        message = "ë¬´ê²Œê°€ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒí’ˆ ìˆ˜ëŸ‰ì„ ë³€ê²½í•˜ê±°ë‚˜ ìƒí’ˆì„ ì¶”ê°€í•´ ì£¼ì„¸ìš”."
    else:
        status = "UNDER_WEIGHT"
        message = "ë¬´ê²Œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ìƒí’ˆì„ ì‚­ì œí•˜ê±°ë‚˜ ìˆ˜ëŸ‰ì„ ë³€ê²½í•´ ì£¼ì„¸ìš”."

    cart.expected_total_g = expected_weight
    cart.measured_total_g = measured_weight_g

    return {
        "is_valid": status == "MATCH",
        "status": status,
        "expected_weight": expected_weight,
        "measured_weight": measured_weight_g,
        "difference": difference,
        "tolerance": tolerance,
        "message": message
    }

----------------------------------------
End of file: app\utils\check_data.py


Start of file: app\utils\email.py
----------------------------------------
# app/utils/email.py

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from os import getenv

SMTP_HOST = getenv("SMTP_HOST")
SMTP_PORT = int(getenv("SMTP_PORT"))
SMTP_USER = getenv("SMTP_USER")
SMTP_PASSWORD = getenv("SMTP_PASSWORD")


def send_reset_password_email(to_email: str, reset_link: str):
    msg = MIMEMultipart()
    msg["From"] = SMTP_USER
    msg["To"] = to_email
    msg["Subject"] = "[SmartCart] ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì•ˆë‚´"

    body = f"""
ì•ˆë…•í•˜ì„¸ìš”.

ì•„ë˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì¬ì„¤ì •í•´ì£¼ì„¸ìš”.

{reset_link}

ë³¸ ë§í¬ëŠ” ì¼ì • ì‹œê°„ í›„ ë§Œë£Œë©ë‹ˆë‹¤.
"""
    msg.attach(MIMEText(body, "plain"))

    with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
        server.starttls()
        server.login(SMTP_USER, SMTP_PASSWORD)
        server.send_message(msg)

----------------------------------------
End of file: app\utils\email.py


Start of file: app\utils\jwt.py
----------------------------------------
# app/utils/jwt.py
from datetime import datetime, timedelta
from jose import jwt, JWTError, ExpiredSignatureError
from typing import Optional
from fastapi import HTTPException, status

SECRET_KEY = "SECRET_KEY"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7


def create_access_token(subject: str, expires_delta: Optional[timedelta] = None) -> str:
    expire = datetime.utcnow() + (
        expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    payload = {
        "sub": subject,
        "exp": expire,
        "type": "access",
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def create_refresh_token(subject: str, expires_delta: Optional[timedelta] = None) -> str:
    expire = datetime.utcnow() + (
        expires_delta or timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    )

    payload = {
        "sub": subject,
        "exp": expire,
        "type": "refresh",
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> dict:
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token expired"
        )
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )

----------------------------------------
End of file: app\utils\jwt.py


Start of file: app\utils\security.py
----------------------------------------
# app/utils/security.py
from passlib.context import CryptContext

pwd_context = CryptContext(
    schemes=["argon2"],
    deprecated="auto"
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

----------------------------------------
End of file: app\utils\security.py


Start of file: scripts\reset_db.py
----------------------------------------
import os
import sys
from sqlalchemy import create_engine, text
from app.core.config import settings

def reset_database():
    print("ğŸ—‘ï¸ Database reset initiated...")
    
    # DB URL í™•ì¸
    db_url = settings.DATABASE_URL
    if not db_url:
        print("âŒ DATABASE_URL not found!")
        sys.exit(1)
        
    engine = create_engine(db_url)
    
    # Drop all tables and types logic
    # CASCADEë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ì¡´ì„± ìˆëŠ” ê°ì²´ë“¤ë„ ëª¨ë‘ ì‚­ì œ
    drop_sql = text("""
    DO $$ DECLARE
        r RECORD;
    BEGIN
        -- 1. Drop all tables
        FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
            EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
        END LOOP;
        
        -- 2. Drop all enums/types
        FOR r IN (SELECT typname FROM pg_type t JOIN pg_namespace n ON t.typnamespace = n.oid WHERE n.nspname = 'public' AND t.typtype = 'e') LOOP
            EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
        END LOOP;
        
        -- 3. Clear alembic_version table just in case
        EXECUTE 'DROP TABLE IF EXISTS alembic_version CASCADE';
    END $$;
    """)
    
    try:
        with engine.connect() as conn:
            conn.execute(drop_sql)
            conn.commit()
        print("âœ… Database successfully cleared (Tables & Types dropped).")
    except Exception as e:
        print(f"âŒ Failed to reset database: {e}")
        sys.exit(1)

if __name__ == "__main__":
    reset_database()

----------------------------------------
End of file: scripts\reset_db.py


Start of file: scripts\run_sql.py
----------------------------------------
import os
import sys
from sqlalchemy import create_engine, text
from app.core.config import settings

def run_seed_sql():
    print("ğŸŒ± Seeding database from SQL file...")
    
    db_url = settings.DATABASE_URL
    if not db_url:
        print("âŒ DATABASE_URL not found!")
        sys.exit(1)
        
    engine = create_engine(db_url)
    
    # SQL íŒŒì¼ ê²½ë¡œ
    sql_file_path = os.path.join(os.path.dirname(__file__), "seed_data.sql")
    
    try:
        with open(sql_file_path, "r", encoding="utf-8") as f:
            sql_content = f.read()
            
        with engine.connect() as conn:
            # SQL ë¬¸ì¥ì„ ì„¸ë¯¸ì½œë¡ (;) ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•Šê³  í†µì§¸ë¡œ ì‹¤í–‰í•˜ë ¤ë©´ text() ì‚¬ìš©
            # í•˜ì§€ë§Œ ì—¬ëŸ¬ ë¬¸ì¥ì´ ì„ì—¬ ìˆìœ¼ë¯€ë¡œ, text()ê°€ ì´ë¥¼ ì§€ì›í•˜ëŠ”ì§€ DB ë“œë¼ì´ë²„ì— ë”°ë¼ ë‹¤ë¦„.
            # PostgreSQL(psycopg2)ì€ ì§€ì›í•¨.
            conn.execute(text(sql_content))
            conn.commit()
            
        print("âœ… Data seeded successfully!")
    except Exception as e:
        print(f"âŒ Failed to seed data: {e}")
        sys.exit(1)

if __name__ == "__main__":
    run_seed_sql()

----------------------------------------
End of file: scripts\run_sql.py


Start of file: scripts\seed_data.sql
----------------------------------------
-- [1. ì´ˆê¸°í™”] ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
TRUNCATE TABLE recipe_ingredient, recipe, cart_item, product, product_category CASCADE;

-- ========================================================
-- ğŸ·ï¸ 1. ì¹´í…Œê³ ë¦¬ (ê¸°ì¡´ + íŒ€ì› ë°ì´í„° í†µí•©)
-- ========================================================
-- [ê¸°ì¡´] 1~5ë²ˆ
INSERT INTO product_category (category_id, name, zone_code) VALUES 
(1, 'ì±„ì†Œ/ê³¼ì¼', 'A-01'),
(2, 'ì •ìœ¡/ê³„ë€', 'B-02'),
(3, 'ìˆ˜ì‚°/í•´ì‚°ë¬¼', 'C-03'),
(4, 'ê°€ê³µ/ìœ ì œí’ˆ', 'D-04'),
(5, 'ì–‘ë…/ì˜¤ì¼', 'E-05');

-- [íŒ€ì› - AI ì‹œì—°ìš©] 11~16ë²ˆ (ID ì¶©ëŒ ë°©ì§€ ìœ„í•´ ë²ˆí˜¸ ì´ë™)
INSERT INTO product_category (category_id, name, zone_code) VALUES
(11, 'í†µì¡°ë¦¼', 'A-10'),
(12, 'ì†ŒìŠ¤ë¥˜', 'A-20'),
(13, 'ë©´ë¥˜', 'A-30'),
(14, 'ì¦‰ì„ì‹í’ˆ', 'B-10'),
(15, 'ì¼/ìŠ¤í”„ë ˆë“œ', 'B-20'),
(16, 'ìŒë£Œ', 'C-10');


-- ========================================================
-- ğŸ¥« 2. ìƒí’ˆ ë°ì´í„°
-- ========================================================

-- [Team AI ì‹œì—° ë¬¼í’ˆ] (ID 1~8 ìœ ì§€ / ì¹´í…Œê³ ë¦¬ë§Œ 11ë²ˆëŒ€ë¡œ ë§¤í•‘)
INSERT INTO product (product_id, category_id, barcode, name, price, unit_weight_g, stock_quantity, image_url, product_info) VALUES
(1, 11, '8801000000001', 'ìŠ¤íŒ¸ 200g', 5200, 200, 30, 'https://example.com/spam.jpg', '{"code":"spam_200g","brand":"CJ"}'),
(2, 12, '8801000000002', 'í† ë§ˆí†  ì¼€ì°¹ 300g', 2800, 300, 40, 'https://example.com/ketchup.jpg', '{"code":"tomato_ketchup_300g"}'),
(3, 13, '8801000000003', 'ìŠ¤íŒŒê²Œí‹°ë©´ 500g', 3200, 500, 25, 'https://example.com/spaghetti.jpg', '{"code":"spaghetti_noodle_500g"}'),
(4, 11, '8801000000004', 'ì‚´ì½”ê¸°ì°¸ì¹˜ 90g', 2200, 90, 18, 'https://example.com/tuna.jpg', '{"code":"tuna_lean_90g"}'),
(5, 14, '8801000000005', '3ë¶„ì¹´ë ˆ ì•½ê°„ë§¤ìš´ë§›', 3500, 200, 20, 'https://example.com/curry.jpg', '{"code":"curry_3min_mildhot_200g","spicy":"mild"}'),
(6, 15, '8801000000006', 'ë”¸ê¸°ì¼ 570g', 4800, 570, 15, 'https://example.com/jam.jpg', '{"code":"strawberry_jam_570g"}'),
(7, 13, '8801000000007', 'ì‹ ë¼ë©´', 950, 120, 100, 'https://example.com/shinramen.jpg', '{"code":"shin_ramen","spicy":"hot"}'),
(8, 16, '8801000000008', 'í©ì‹œ ì œë¡œìŠˆê±° ë¼ì„', 2100, 500, 50, 'https://example.com/pepsi.jpg', '{"code":"pepsi_zero_lime_500ml","sugar":"zero"}');

-- [ê¸°ì¡´ ë”ë¯¸ ë¬¼í’ˆ] (ID 100ë²ˆëŒ€ - ì‹œì—° ë¬¼í’ˆê³¼ ì—°ê²°ë  ì¬ë£Œë“¤)
INSERT INTO product (product_id, category_id, name, price, unit_weight_g, barcode, image_url) VALUES 
(100, 1, 'í–‡ ì–‘íŒŒ', 3500, 1000, '8801000001001', 'https://example.com/onion.jpg'),
(101, 1, 'ëŒ€íŒŒ (í•œë‹¨)', 2800, 400, '8801000001002', 'https://example.com/greenonion.jpg'),
(102, 1, 'ë‹¤ì§„ ë§ˆëŠ˜', 4500, 200, '8801000001003', 'https://example.com/garlic.jpg'),
(103, 1, 'ì²­ì–‘ê³ ì¶”', 1500, 100, '8801000001004', 'https://example.com/chili.jpg'),
(104, 1, 'ì• í˜¸ë°•', 1200, 300, '8801000001005', 'https://example.com/zucchini.jpg'),
(105, 1, 'ê°ì (í™ê°ì)', 4000, 800, '8801000001006', 'https://example.com/potato.jpg'),
(106, 1, 'ë‹¹ê·¼', 2000, 300, '8801000001007', 'https://example.com/carrot.jpg'),
(200, 2, 'í•œëˆ ìƒì‚¼ê²¹ì‚´', 15900, 600, '8802000002001', 'https://example.com/porkbelly.jpg'),
(300, 4, 'ì°Œê°œìš© ë‘ë¶€', 1500, 300, '8803000003001', 'https://example.com/tofu.jpg'),
(301, 4, 'ì¢…ê°€ì§‘ ë§›ê¹€ì¹˜', 8900, 1000, '8803000003002', 'https://example.com/kimchi.jpg'),
(303, 3, 'ë¶€ì‚° ì‚¬ê°ì–´ë¬µ', 3000, 250, '8803000003004', 'https://example.com/fishcake.jpg'),
(400, 5, 'íƒœì–‘ì´ˆ ê³ ì¶”ì¥', 7500, 500, '8804000004001', 'https://example.com/gochujang.jpg'),
(401, 5, 'ì¬ë˜ì‹ ëœì¥', 6900, 500, '8804000004002', 'https://example.com/doenjang.jpg'),
(402, 5, 'ì§„ê°„ì¥', 5000, 900, '8804000004003', 'https://example.com/soysauce.jpg'),
(403, 5, 'ì°¸ê¸°ë¦„', 8000, 300, '8804000004004', 'https://example.com/sesameoil.jpg'),
(404, 5, 'ì„¤íƒ•', 3000, 1000, '8804000004005', 'https://example.com/sugar.jpg');


-- ========================================================
-- ğŸ³ 3. ë ˆì‹œí”¼ (ì‹œì—° ë¬¼í’ˆê³¼ ê¸°ì¡´ ì¬ë£Œë¥¼ ì—®ëŠ” ì—°ê²°ê³ ë¦¬!)
-- ========================================================

INSERT INTO recipe (recipe_id, title, description, instructions) VALUES 
-- [ê¸°ì¡´] 
(1, 'ë¼ì§€ê³ ê¸° ê¹€ì¹˜ì°Œê°œ', 'í•œêµ­ì¸ì˜ ì†Œìš¸í‘¸ë“œ! ì¹¼ì¹¼í•˜ê³  ê¹Šì€ ë§›ì˜ ê¹€ì¹˜ì°Œê°œ.', 'ì„¤ëª… ìƒëµ...'),
(2, 'ì°¨ëŒ ëœì¥ì°Œê°œ', 'êµ¬ìˆ˜í•¨ì˜ ëíŒì™• ëœì¥ì°Œê°œ.', 'ì„¤ëª… ìƒëµ...'),
(10, 'ì˜ì •ë¶€ì‹ ë¶€ëŒ€ì°Œê°œ', 'ìŠ¤íŒ¸ê³¼ ë¼ë©´ì‚¬ë¦¬ì˜ í™˜ìƒ ì¡°í•©! ì§‘ì—ì„œ ì¦ê¸°ëŠ” ì§„í•œ ë¶€ëŒ€ì°Œê°œì…ë‹ˆë‹¤.', 
'1. ëƒ„ë¹„ì— ê¹€ì¹˜, ìŠ¤íŒ¸, ì†Œì‹œì§€, ë‘ë¶€ë¥¼ ë‘˜ëŸ¬ ë‹´ìŠµë‹ˆë‹¤.\n2. ì–‘ë…ì¥(ê³ ì¶”ì¥, ë§ˆëŠ˜, ê°„ì¥)ì„ ì–¹ê³  ë¬¼ì„ ë¶“ìŠµë‹ˆë‹¤.\n3. ë“ì–´ì˜¤ë¥´ë©´ ë¼ë©´ì‚¬ë¦¬(ì‹ ë¼ë©´)ë¥¼ ë„£ìŠµë‹ˆë‹¤.\n4. ëŒ€íŒŒë¥¼ ë“¬ë¿ ë„£ê³  ë©´ì´ ìµì„ ë•Œê¹Œì§€ ë“ì´ë©´ ì™„ì„±!'),
(11, '3ë¶„ ì»· ì°¸ì¹˜ ê¹€ì¹˜ì°Œê°œ', 'ì‚´ì½”ê¸° ì°¸ì¹˜ì˜ ë‹´ë°±í•¨ì´ êµ­ë¬¼ì— ì™! ì´ˆê°„ë‹¨ ë°¥ë„ë‘‘.', 
'1. ëƒ„ë¹„ì— ì°¸ê¸°ë¦„ì„ ë‘ë¥´ê³  ê¹€ì¹˜ë¥¼ ë³¶ìŠµë‹ˆë‹¤.\n2. ë¬¼ì„ ë¶“ê³  ë“ìœ¼ë©´ ì°¸ì¹˜ ê¸°ë¦„ê¹Œì§€ í•¨ê»˜ ë„£ìŠµë‹ˆë‹¤.\n3. ì–‘íŒŒì™€ ëŒ€íŒŒë¥¼ ë„£ê³  í‘¹ ë“ì—¬ëƒ…ë‹ˆë‹¤.'),
(12, 'ì¶”ì–µì˜ ë‚˜í´ë¦¬íƒ„ ìŠ¤íŒŒê²Œí‹°', 'ì¼€ì°¹ìœ¼ë¡œ ë§Œë“œëŠ” ë‹¬ì½¤ìƒˆì½¤í•œ ë§›. ì•„ì´ë“¤ì´ ì •ë§ ì¢‹ì•„í•´ìš”.', 
'1. ë“ëŠ” ë¬¼ì— ìŠ¤íŒŒê²Œí‹° ë©´ì„ ì‚¶ìŠµë‹ˆë‹¤.\n2. íŒ¬ì— ê¸°ë¦„ì„ ë‘ë¥´ê³  í¸ë§ˆëŠ˜, ì–‘íŒŒ, ì†Œì„¸ì§€ë¥¼ ë³¶ìŠµë‹ˆë‹¤.\n3. ì‚¶ì€ ë©´ê³¼ ì¼€ì°¹ 4í°ìˆ ì„ ë„£ê³  ë³¶ìŠµë‹ˆë‹¤.\n4. ë©´ìˆ˜ë¥¼ ì•½ê°„ ë„£ì–´ ë†ë„ë¥¼ ë§ì¶”ë©´ ì™„ì„±!');


-- ========================================================
-- ğŸ”— 4. ë ˆì‹œí”¼-ì¬ë£Œ ì—°ê²° (ë§¤í•‘)
-- ========================================================

-- ê¸°ì¡´ ê¹€ì¹˜ì°Œê°œ (ë¼ì§€ê³ ê¸° ì‚¬ìš©)
INSERT INTO recipe_ingredient (recipe_id, product_id, quantity_info, importance_score) VALUES 
(1, 200, '300g', 5), (1, 301, '1/4í¬ê¸°', 5), (1, 300, 'ë°˜ ëª¨', 3), (1, 101, '1ëŒ€', 3);

-- ê¸°ì¡´ ëœì¥ì°Œê°œ
INSERT INTO recipe_ingredient (recipe_id, product_id, quantity_info, importance_score) VALUES 
(2, 401, '2í°ìˆ ', 5), (2, 300, 'ë°˜ ëª¨', 3), (2, 104, '1/3ê°œ', 3), (2, 105, '1ê°œ', 3);


-- âœ¨ [ì‹œì—°ìš© 1] ë¶€ëŒ€ì°Œê°œ (ìŠ¤íŒ¸, ë¼ë©´ -> ê¹€ì¹˜, ë‘ë¶€, ëŒ€íŒŒ ì¶”ì²œ)
INSERT INTO recipe_ingredient (recipe_id, product_id, quantity_info, importance_score) VALUES 
(10, 1, '1ìº”', 5),   -- ìŠ¤íŒ¸ (ì‹œì—° ë¬¼í’ˆ)
(10, 7, '1ê°œ', 5),   -- ì‹ ë¼ë©´ (ì‹œì—° ë¬¼í’ˆ)
(10, 301, 'ë°˜í¬ê¸°', 5), -- ê¹€ì¹˜ (ì¶”ê°€ êµ¬ë§¤ ìœ ë„!)
(10, 300, 'í•œëª¨', 3),   -- ë‘ë¶€ (ì¶”ê°€ êµ¬ë§¤ ìœ ë„!)
(10, 101, '2ëŒ€', 3),    -- ëŒ€íŒŒ (ì¶”ê°€ êµ¬ë§¤ ìœ ë„!)
(10, 400, '1í°ìˆ ', 1);  -- ê³ ì¶”ì¥

-- âœ¨ [ì‹œì—°ìš© 2] ì°¸ì¹˜ ê¹€ì¹˜ì°Œê°œ (ì°¸ì¹˜ -> ê¹€ì¹˜, ì–‘íŒŒ ì¶”ì²œ)
INSERT INTO recipe_ingredient (recipe_id, product_id, quantity_info, importance_score) VALUES 
(11, 4, '1ìº”', 5),   -- ì°¸ì¹˜ (ì‹œì—° ë¬¼í’ˆ)
(11, 301, 'ë°˜í¬ê¸°', 5), -- ê¹€ì¹˜ (ì¶”ê°€ êµ¬ë§¤ ìœ ë„!)
(11, 100, 'ë°˜ê°œ', 3),   -- ì–‘íŒŒ
(11, 103, '1ê°œ', 1);    -- ì²­ì–‘ê³ ì¶”

-- âœ¨ [ì‹œì—°ìš© 3] ë‚˜í´ë¦¬íƒ„ (ìŠ¤íŒŒê²Œí‹°, ì¼€ì°¹ -> ì–‘íŒŒ ì¶”ì²œ)
INSERT INTO recipe_ingredient (recipe_id, product_id, quantity_info, importance_score) VALUES 
(12, 3, '1ì¸ë¶„', 5),  -- ìŠ¤íŒŒê²Œí‹°ë©´ (ì‹œì—° ë¬¼í’ˆ)
(12, 2, '4í°ìˆ ', 5),  -- ì¼€ì°¹ (ì‹œì—° ë¬¼í’ˆ)
(12, 100, 'ë°˜ê°œ', 3),   -- ì–‘íŒŒ
(12, 102, '1í°ìˆ ', 1);  -- ë§ˆëŠ˜

----------------------------------------
End of file: scripts\seed_data.sql


Start of file: tests\manual\check_db_data.py
----------------------------------------
"""
[DB ë°ì´í„° ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸]
ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” íŠ¹ì • ìœ ì €ì˜ ì´ë©”ì¼ì„ ê¸°ë°˜ìœ¼ë¡œ ê´€ë ¨ DB ë°ì´í„°ê°€ ì •ìƒì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
SQLAlchemyë¥¼ ì‚¬ìš©í•˜ì—¬ DBì— ì§ì ‘ ì ‘ì†í•©ë‹ˆë‹¤.

ê²€ì¦ í•­ëª©:
1. ìœ ì € ì •ë³´ (User)
2. ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ ìƒíƒœ (CartSession) - PAID ì—¬ë¶€
3. ê²°ì œ ë‚´ì—­ (Payment) - APPROVED ì—¬ë¶€
4. ê°€ê³„ë¶€ ë‚´ì—­ (LedgerEntry) - ìƒì„± ì—¬ë¶€

ì‹¤í–‰ ë°©ë²•:
ìŠ¤í¬ë¦½íŠ¸ í•˜ë‹¨ì˜ verify_data("ì´ë©”ì¼") ë¶€ë¶„ì„ ìˆ˜ì •í•œ ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.
$ python -m tests.manual.check_db_data
"""
import sys
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app import models
from app.db.base import Base

# DB ì—°ê²° ì„¤ì •
SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://admin:password123@localhost:5432/postgres")
if os.getenv("DB_PASSWORD"): # í™˜ê²½ë³€ìˆ˜ì— ë¹„ë²ˆì´ ë”°ë¡œ ìˆìœ¼ë©´ ì¡°í•© (ì¼ë°˜ì ì¸ ê²½ìš° .envì—ì„œ ë¡œë“œë¨)
    pass 

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
db = SessionLocal()

def verify_data(email):
    print(f"ğŸ” '{email}' ìœ ì € ë°ì´í„° ì¡°íšŒ ì¤‘...\n")

    # 1. ìœ ì € ì°¾ê¸°
    user = db.query(models.AppUser).filter(models.AppUser.email == email).first()
    if not user:
        print("âŒ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return

    print(f"ğŸ‘¤ ìœ ì € ID: {user.user_id}, ë‹‰ë„¤ì„: {user.nickname}")

    # 2. ì¹´íŠ¸ ì„¸ì…˜ í™•ì¸
    cart = db.query(models.CartSession).filter(
        models.CartSession.user_id == user.user_id,
        models.CartSession.status == models.CartSessionStatus.PAID
    ).order_by(models.CartSession.cart_session_id.desc()).first()
    
    if cart:
        print(f"ğŸ›’ [ì™„ë£Œëœ ì¥ë°”êµ¬ë‹ˆ] ID: {cart.cart_session_id}, ìƒíƒœ: {cart.status.value}, ì¢…ë£Œì‹œê°„: {cart.ended_at}")
    else:
        print("âš ï¸ ì™„ë£Œëœ(PAID) ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.")

    # 3. ê²°ì œ ë‚´ì—­ í™•ì¸
    payment = db.query(models.Payment).filter(models.Payment.user_id == user.user_id).order_by(models.Payment.payment_id.desc()).first()
    if payment:
        print(f"ğŸ’³ [ê²°ì œ ë‚´ì—­] ID: {payment.payment_id}, TID: {payment.pg_tid}, ê¸ˆì•¡: {payment.total_amount}ì›, ìƒíƒœ: {payment.status.value}")
    else:
        print("âš ï¸ ê²°ì œ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")

    # 4. ê°€ê³„ë¶€ ë‚´ì—­ í™•ì¸ (ë©”ëª¨ ì»¬ëŸ¼ ì œì™¸í•˜ê³  ì¡°íšŒ)
    # models.LedgerEntry ì „ì²´ë¥¼ ì¡°íšŒí•˜ë©´ ìŠ¤í‚¤ë§ˆ ë¶ˆì¼ì¹˜ë¡œ ì—ëŸ¬ê°€ ë°œìƒí•˜ë¯€ë¡œ í•„ìš”í•œ í•„ë“œë§Œ ì¡°íšŒ
    ledger = db.query(
        models.LedgerEntry.ledger_entry_id,
        models.LedgerEntry.spend_date,
        models.LedgerEntry.amount,
        models.LedgerEntry.category
    ).filter(models.LedgerEntry.user_id == user.user_id).order_by(models.LedgerEntry.ledger_entry_id.desc()).first()

    if ledger:
        # íŠœí”Œë¡œ ë°˜í™˜ë˜ë¯€ë¡œ ì¸ë±ìŠ¤ë‚˜ ì´ë¦„ìœ¼ë¡œ ì ‘ê·¼ ë¶ˆê°€í•  ìˆ˜ ìˆì–´ ë‹¨ìˆœ ì¶œë ¥
        print(f"ğŸ“” [ê°€ê³„ë¶€] ID: {ledger.ledger_entry_id}, ë‚ ì§œ: {ledger.spend_date}, ê¸ˆì•¡: {ledger.amount}ì›, ì¹´í…Œê³ ë¦¬: {ledger.category.value}")
    else:
        print("âš ï¸ ê°€ê³„ë¶€ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")

if __name__ == "__main__":
    verify_data("test_fy97rs9d@example.com")

----------------------------------------
End of file: tests\manual\check_db_data.py


Start of file: tests\manual\test_payment_approve.py
----------------------------------------
"""
[ê²°ì œ ì „ì²´ í”„ë¡œì„¸ìŠ¤ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ - Part 2]
ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ì¹´ì¹´ì˜¤í˜ì´ ê²°ì œ ìŠ¹ì¸(Approve) APIë¥¼ í˜¸ì¶œí•˜ì—¬ ìµœì¢… ê²°ì œë¥¼ ì™„ë£Œí•©ë‹ˆë‹¤.
ë¸Œë¼ìš°ì €ì—ì„œ ê²°ì œ ì™„ë£Œ í›„ ë°œê¸‰ë°›ì€ pg_tokenì´ í•„ìš”í•©ë‹ˆë‹¤.

ê¸°ëŠ¥:
1. ì‚¬ìš©ì ë¡œê·¸ì¸ (í† í° ë°œê¸‰)
2. ê²°ì œ ìŠ¹ì¸ API í˜¸ì¶œ
3. ê²°ì œ ìƒíƒœ(APPROVED) ë° ê°€ê³„ë¶€ ìƒì„± í™•ì¸

ì‹¤í–‰ ë°©ë²•:
$ python -m tests.manual.test_payment_approve <ì´ë©”ì¼> <ë¹„ë°€ë²ˆí˜¸> <TID> <PG_TOKEN>
ì˜ˆ: python -m tests.manual.test_payment_approve test@example.com TestPass123! T123... pg_token...
"""
import requests
import sys

BASE_URL = "http://localhost:8000"
API_AUTH_LOGIN = f"{BASE_URL}/api/auth/login"
API_PAYMENT_APPROVE = f"{BASE_URL}/api/payments/approve"

def login(email, password):
    res = requests.post(API_AUTH_LOGIN, json={"email": email, "password": password})
    if res.status_code != 200:
        print("âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨")
        sys.exit(1)
    return res.json()["access_token"]

def main():
    if len(sys.argv) < 5:
        print("ì‚¬ìš©ë²•: python test_payment_approve.py <email> <password> <tid> <pg_token>")
        return

    email = sys.argv[1]
    password = sys.argv[2]
    tid = sys.argv[3]
    pg_token = sys.argv[4]

    token = login(email, password)
    headers = {"Authorization": f"Bearer {token}"}

    print(f"ğŸ’³ ê²°ì œ ìŠ¹ì¸(Approve) ìš”ì²­ ì¤‘... (TID: {tid})")
    
    # schemas.PaymentApproveRequest í˜•ì‹ì— ë§ì¶¤
    payload = {
        "tid": tid,
        "pg_token": pg_token,
        "partner_order_id": "dummy", # ì„œë²„ ë¡œì§ì—ì„œ DB ê°’ìœ¼ë¡œ ëŒ€ì²´í•˜ë¯€ë¡œ dummy ì „ë‹¬ ê°€ëŠ¥
        "partner_user_id": "dummy"
    }

    res = requests.post(API_PAYMENT_APPROVE, headers=headers, json=payload)

    if res.status_code == 200:
        print("\n" + "="*50)
        print("âœ… ê²°ì œ ìµœì¢… ìŠ¹ì¸ ì„±ê³µ!!!")
        print(f"ê²°ì œ ID: {res.json().get('payment_id')}")
        print(f"ìƒíƒœ: {res.json().get('status')}")
        print(f"ìŠ¹ì¸ ì‹œê°: {res.json().get('approved_at')}")
        print("="*50)
        print("â„¹ï¸ ì´ì œ DBì˜ cart_session ìƒíƒœê°€ 'PAID'ë¡œ ë³€ê²½ë˜ì—ˆê³ , ê°€ê³„ë¶€(Ledger)ì— ë‚´ì—­ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.")
    else:
        print(f"âŒ ìŠ¹ì¸ ì‹¤íŒ¨: {res.text}")

if __name__ == "__main__":
    main()

----------------------------------------
End of file: tests\manual\test_payment_approve.py


Start of file: tests\manual\test_payment_flow.py
----------------------------------------
"""
[ê²°ì œ ë¡œì§ í†µí•© í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ - ìˆ˜ì •ë³¸]
ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ìƒˆë¡œìš´ '/api/payments/request' ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ
ì¥ë°”êµ¬ë‹ˆ ë¬´ê²Œ ê²€ì¦ ë° ê²°ì œ ë¶„ê¸° ì²˜ë¦¬ë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.

ê¸°ëŠ¥:
1. ìœ ì € ìƒì„± ë° ë¡œê·¸ì¸
2. í…ŒìŠ¤íŠ¸ ìƒí’ˆ(ë¬´ê²Œ 100g) ìƒì„±
3. ì¥ë°”êµ¬ë‹ˆì— ìƒí’ˆ ë‹´ê¸° (2ê°œ -> ì˜ˆìƒ ë¬´ê²Œ 200g)
4. [í…ŒìŠ¤íŠ¸ 1] ë¬´ê²Œ ë¶ˆì¼ì¹˜ ì‹œë‚˜ë¦¬ì˜¤ (150g ì „ì†¡) -> 409 Conflict ì˜ˆìƒ
5. [í…ŒìŠ¤íŠ¸ 2] ë¬´ê²Œ ì¼ì¹˜ ì‹œë‚˜ë¦¬ì˜¤ (200g ì „ì†¡) -> 200 OK ì˜ˆìƒ

ì‹¤í–‰ ë°©ë²•:
$ cd backend
$ python -m tests.manual.test_payment_flow
"""
import requests
import random
import string
import sys
import os

# --- ì„¤ì • ---
BASE_URL = "http://localhost:8000"
API_AUTH_SIGNUP = f"{BASE_URL}/api/auth/signup"
API_AUTH_LOGIN = f"{BASE_URL}/api/auth/login"
API_PAYMENT_REQUEST = f"{BASE_URL}/api/payments/request"

# --- ìœ í‹¸ë¦¬í‹° ---
def random_string(length=8):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def create_random_user():
    email = f"test_{random_string()}@example.com"
    password = "TestPassword123!"
    nick_rand = ''.join(random.choices(string.ascii_lowercase, k=4))
    nickname = f"User{nick_rand}"
    
    print(f"ğŸ†• íšŒì›ê°€ì… ì‹œë„: {email}")
    requests.post(API_AUTH_SIGNUP, json={
        "email": email,
        "password": password,
        "nickname": nickname
    })
    return email, password

def login(email, password):
    res = requests.post(API_AUTH_LOGIN, json={"email": email, "password": password})
    if res.status_code != 200:
        print(f"âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: {res.text}")
        sys.exit(1)
    return res.json()["access_token"]

def ensure_test_product_exists():
    """í…ŒìŠ¤íŠ¸ìš© ìƒí’ˆ(100g, 1500ì›) ìƒì„±/ì¡°íšŒ"""
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
    from app.database import SessionLocal
    from app import models
    
    db = SessionLocal()
    try:
        # í…ŒìŠ¤íŠ¸ ì¹´í…Œê³ ë¦¬ í™•ì¸
        category = db.query(models.ProductCategory).filter_by(name="í…ŒìŠ¤íŠ¸ì¹´í…Œê³ ë¦¬").first()
        if not category:
            category = models.ProductCategory(name="í…ŒìŠ¤íŠ¸ì¹´í…Œê³ ë¦¬", zone_code="T-1")
            db.add(category)
            db.commit()

        # í…ŒìŠ¤íŠ¸ ìƒí’ˆ í™•ì¸
        product_name = "í…ŒìŠ¤íŠ¸ìš© ê³¼ì(100g)"
        product = db.query(models.Product).filter_by(name=product_name).first()
        
        if not product:
            print("ğŸ“¦ í…ŒìŠ¤íŠ¸ ìƒí’ˆ ìƒì„± ì¤‘...")
            new_product = models.Product(
                category_id=category.category_id,
                name=product_name,
                price=1500,
                unit_weight_g=100,  # 100g
                barcode=f"TEST{random.randint(1000,9999)}"
            )
            db.add(new_product)
            db.commit()
            db.refresh(new_product)
            return new_product.product_id
        
        return product.product_id
    except Exception as e:
        print(f"âš ï¸ DB ì˜¤ë¥˜: {e}")
        sys.exit(1)
    finally:
        db.close()

def main():
    print("ğŸš€ [ê²°ì œ/ë¬´ê²Œ ê²€ì¦ í…ŒìŠ¤íŠ¸] ì‹œì‘í•©ë‹ˆë‹¤...")
    
    # 0. ì¤€ë¹„
    product_id = ensure_test_product_exists() 
    email, password = create_random_user()
    token = login(email, password)
    headers = {"Authorization": f"Bearer {token}"}

    # 1. ì¹´íŠ¸ ì„¸ì…˜ ì¤€ë¹„
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
    from app.database import SessionLocal
    from app import models
    db = SessionLocal()
    
    device_code = "TEST_DEVICE_001"
    device = db.query(models.CartDevice).filter_by(device_code=device_code).first()
    if not device:
        device = models.CartDevice(device_code=device_code)
        db.add(device)
        db.commit()
        db.refresh(device)
    
    user_id = db.query(models.AppUser).filter_by(email=email).first().user_id
    
    # ê¸°ì¡´ í™œì„± ì„¸ì…˜ ì •ë¦¬
    db.query(models.CartSession).filter_by(user_id=user_id, status=models.CartSessionStatus.ACTIVE).update({"status": models.CartSessionStatus.CANCELLED})
    db.commit()
    
    new_session = models.CartSession(
        cart_device_id=device.cart_device_id,
        user_id=user_id,
        status=models.CartSessionStatus.ACTIVE
    )
    db.add(new_session)
    db.commit()
    db.refresh(new_session)
    cart_session_id = new_session.cart_session_id
    db.close()
    
    print(f"âœ… ì„¸ì…˜ ì¤€ë¹„ ì™„ë£Œ: ID {cart_session_id}")

    # 2. ìƒí’ˆ ë‹´ê¸° (100g * 2ê°œ = 200g, 3000ì›)
    # ìˆ˜ì •ëœ ê²½ë¡œ: /api/carts/{session_id}/items
    print(f"â• ìƒí’ˆ ë‹´ê¸° (ID: {product_id}, 2ê°œ)...")
    API_CART_ADD_ITEM = f"{BASE_URL}/api/carts/{cart_session_id}/items"
    res = requests.post(API_CART_ADD_ITEM, headers=headers, json={
        "product_id": product_id,
        "quantity": 2
    })
    if res.status_code != 200:
        print(f"âŒ ìƒí’ˆ ë‹´ê¸° ì‹¤íŒ¨: {res.status_code} - {res.text}")
        sys.exit(1)
    print("âœ… ìƒí’ˆ ë‹´ê¸° ì„±ê³µ")

    # 3. [TEST CASE 1] ë¬´ê²Œ ë¶ˆì¼ì¹˜ í…ŒìŠ¤íŠ¸
    print("\nâš–ï¸  [CASE 1] ë¬´ê²Œ ë¶ˆì¼ì¹˜ í…ŒìŠ¤íŠ¸ (ì˜ˆìƒ 200g vs ì¸¡ì • 150g)")
    payload_fail = {
        "cart_session_id": cart_session_id,
        "measured_weight_g": 150,  
        "amount": 3000,
        "use_subscription": False
    }
    res = requests.post(API_PAYMENT_REQUEST, headers=headers, json=payload_fail)
    
    if res.status_code == 409:
        print("âœ… ì„±ê³µ: 409 Conflict ì‘ë‹µ ë°›ìŒ")
        print(f"   ë©”ì‹œì§€: {res.json().get('message')}")
    else:
        print(f"âŒ ì‹¤íŒ¨: {res.status_code} (ì˜ˆìƒ: 409)")
        print(f"   ì‘ë‹µ: {res.text}")

    # 4. [TEST CASE 2] ë¬´ê²Œ ì¼ì¹˜ í…ŒìŠ¤íŠ¸
    print("\nâš–ï¸  [CASE 2] ë¬´ê²Œ ì¼ì¹˜ í…ŒìŠ¤íŠ¸ (ì˜ˆìƒ 200g vs ì¸¡ì • 200g)")
    payload_success = {
        "cart_session_id": cart_session_id,
        "measured_weight_g": 200, 
        "amount": 3000,
        "use_subscription": False
    }
    res = requests.post(API_PAYMENT_REQUEST, headers=headers, json=payload_success)
    
    if res.status_code == 200:
        print("âœ… ì„±ê³µ: 200 OK ì‘ë‹µ ë°›ìŒ")
        print(f"   ê²°ê³¼: {res.json()}")
    else:
        print(f"âŒ ì‹¤íŒ¨: {res.status_code} (ì˜ˆìƒ: 200)")
        print(f"   ì‘ë‹µ: {res.text}")

    print("\nğŸ í…ŒìŠ¤íŠ¸ ì™„ë£Œ")

if __name__ == "__main__":
    main()

----------------------------------------
End of file: tests\manual\test_payment_flow.py

